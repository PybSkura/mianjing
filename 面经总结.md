
# C++面经
## 一、基础语法
###  1、在main执行之前和之后执行的代码可能是什么？
**main函数执行之前**，主要就是初始化系统相关资源：
> 1. 设置栈指针xu
> 2. 初始化静态static变量和global全局变量，即.data段的内容
> 3. 将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL等等，即.bss段的内容
> 4. 全局对象初始化，在main之前调用构造函数，这是可能会执行前的一些代码
> 5. 将main函数的参数argc，argv等传递给main函数，然后才真正运行main函数
> 6. __attribute__((constructor))

**main函数执行之后**：
> 1. 全局对象的析构函数会在main函数之后执行；
> 2. 可以用 atexit 注册一个函数，它会在main 之后执行
> 3. __attribute__((destructor))

### 2、结构体内存对齐问题？
> 1. 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。
> 2. 未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐)
> 3. c++11以后引入两个关键字 alignas与 alignof。其中alignof可以计算出类型的对齐方式，alignas可以指定结构体的对齐方式。
>    - 若alignas小于自然对齐的最小单位，则被忽略
>    - 如果想使用单字节对齐的方式，使用alignas是无效的。应该使用#pragma pack(push,1)或者使用__attribute__((packed))。

### 3、指针和引用的区别
> 1. 指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名
> 2. 指针可以为空，引用不能为NULL且在定义时必须初始化
> 3. 指针在初始化后可以改变指向，而引用在初始化之后不可再改变
> 4. 引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。
> 5. 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。

### 4、在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？
> 1. 需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的
> 2. 对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小
> 3. 类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式

### 5、堆和栈的区别
1、申请方式不同
> - 栈由系统自动分配
> - 堆是自己申请和释放的

2、申请大小不同
> - 栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改
> - 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整

3、申请效率不同
> - 栈由系统分配，速度快，不会有碎片
> - 堆由程序员分配，速度慢，且会有碎片

**栈空间默认是4M，堆区一般是1G-4G**
### 6、堆快一点还是栈快一点
**毫无疑问是栈快一点**

- 因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。
- 而堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢
### 7、区别以下指针

- int *p[10] 表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。
- int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10
- int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。
- int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。

**后面带(int)的，都是表示函数**
### 8、new / delete 与 malloc / free的异同
1、相同点

- 都可用于内存的动态申请和释放

2、不同点

- 前者是C++运算符，后者是C/C++语言标准库函数
- new自动计算要分配的空间大小，malloc需要手工计算
- new是类型安全的，malloc不是。
```
int *p = new float[2]; //编译错误
int *p = (int*)malloc(2 * sizeof(double));//编译无错误
```

- new调用名为operator new的标准库函数分配足够空间并调用相关对象的构造函数，delete对指针所指对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存。malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能
- malloc/free需要库文件支持，前者不用
- new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象
- malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。
### 9、new和delete是如何实现的？

- new的实现过程是：首先调用名为operator new的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象；接下来运行该类型的一个构造函数，用指定初始化构造对象；最后返回指向新分配并构造后的的对象的指针
- delete的实现过程：对指针指向的对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存
### 10、被free回收的内存是立即返还给操作系统吗？
       	不是的，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。
### 11、宏定义和函数有何区别？

- 宏在编译之前完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。
- 宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值。
- 宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。
- 宏定义不要在最后加分号。
### 14、宏定义和typedef区别？

- 宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。
- 宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。
- 宏不检查类型；typedef会检查数据类型。
- 宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。
- 注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大。
### 15、变量声明和定义区别？

1. **如果是指变量的声明和定义**
- 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。
- 相同变量可以在多处声明（外部变量extern），但只能在一处定义。
2. **如果是指函数的声明和定义**
-  声明：一般在头文件里，对编译器说：这里我有一个函数叫function() 让编译器知道这个函数的存在
-  定义：一般在源文件里，具体就是函数的实现过程 写明函数体
### 16、strlen和sizeof区别？

- sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数
- sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是'\0'的字符串。
```
int main(int argc, char const *argv[]){
			const char* str = "name";
      sizeof(str); // 取的是指针str的长度，是8
      strlen(str); // 取的是这个字符串的长度，不包含结尾的 \0。大小是4       return 0;
}
```
### 17、常量指针和指针常量区别？

- 指针常量(a ptr to const)是一个指针，读成常量的指针，指向一个只读变量，也就是后面所指明的int const 和 const int，都是一个常量，可以写作int const *p或const int *p。
- 常量指针(const ptr)是一个不能给改变指向的指针。指针是个常量，必须初始化，一旦初始化完成，它的值（也就是存放在指针中的地址）就不能在改变了，即不能中途改变指向，如int *const p。
### 18、C++和C语言的区别

- C++中new和delete是对内存分配的运算符，取代了C中的malloc和free。
- 标准C++中的字符串类取代了标准C函数库头文件中的字符数组处理函数（C中没有字符串类型）。 C++中用来做控制态输入输出的iostream类库替代了标准C中的stdio函数库。
- C++中的try/catch/throw异常处理机制取代了标准C中的setjmp()和longjmp()函数。
- 在C++中，允许有相同的函数名，不过它们的参数类型不能完全相同，这样这些函数就可以相互区别开来。而这在C语言中是不允许的。也就是C++可以重载，C语言不允许。
- C++语言中，允许变量定义语句在程序中的任何地方，只要在是使用它之前就可以；而C语言中，必须要在函数开头部分。而且C++允许重复定义变量，C语言也是做不到这一点的
- 在C++中，除了值和指针之外，新增了引用。引用型变量是其他变量的一个别名，我们可以认为他们只是名字不相同，其他都是相同的。
- C++相对与C增加了一些关键字，如：bool、using、dynamic_cast、namespace等等
### 19、C++中struct和class的区别
**相同点**

- 两者都拥有成员函数、公有和私有部分
- 任何可以使用class完成的工作，同样可以使用struct完成

**不同点**

- 两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的
- class默认是private继承，而struct模式是public继承

**C++和C的struct的区别**

- C语言中：struct是用户自定义数据类型（UDT）；C++中struct是抽象数据类型（ADT），支持成员函数的定义，（C++中的struct能继承，能实现多态）
- C中struct是没有权限的设置的，且struct中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员不可以是函数
- C++中，struct增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为public（为了与C兼容）

### 20、C++中const和static的作用
**static**

- 不考虑类的情况
   - 隐藏。所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件所在的编译模块中使用
   - 默认初始化为0，包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区
   - 静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，函数退出后仍然存在，但不能使用
- 考虑类的情况
   - static成员变量：只与类关联，不与类的对象关联。定义时要分配空间，不能在类声明中初始化，必须在类定义体外部初始化，初始化时不需要标示为static；可以被非static成员函数任意访问。
   - static成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；不能被声明为const、虚函数和volatile；可以被非static成员函数任意访问

**const**

- 不考虑类的情况
   - const常量在定义时必须初始化，之后无法更改
   - const形参可以接收const和非const类型的实参
- 考虑类的情况
   - const成员变量：不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化，并且必须有构造函数；不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化
   - const对象不可以调用非const成员函数；非const对象都可以调用；不可以改变非mutable（用该关键字声明的变量可以在const成员函数中被修改）数据的值
### 21、C++的顶层const和底层const

- 顶层const：指的是const修饰的变量本身是一个常量，无法修改，指的是指针，就是 * 号的右边
- 底层const：指的是const修饰的变量所指向的对象是一个常量，指的是所指变量，就是 * 号的左边

**const在*号右边，修饰变量本身是个常量，无法修改**
**const在*号左边，修饰的变量指向的对象是个常量**
```
int a = 10;int* const b1 = &a;//顶层const，b1本身是一个常量
const int* b2 = &a;//底层const，b2本身可变，所指的对象是常量
const int b3 = 20; //顶层const，b3是常量不可变
const int* const b4 = &a; //前一个const为底层，后一个为顶层，b4不可变
```
### 22、数组名和指针（这里为指向数组首元素的指针）区别？

- 二者均可通过增减偏移量来访问数组中的元素。
- 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。
- 当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。
### 23、final和override关键字
**override**
子类重写父类的虚函数时，在重写的虚函数前加上override，会指定子类的这个虚函数是重写的父类的，如果名字不小心打错了的话，编译器是不会编译通过的
**final**
当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错

### 24、拷贝初始化和直接初始化

- 当用于类类型对象时，初始化的拷贝形式和直接形式有所不同：直接初始化直接调用与实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象
```
string str1("I am a string");//语句1 直接初始化
string str2(str1);//语句2 直接初始化，str1是已经存在的对象，直接调用构造函数对str2进行初始
化
string str3 = "I am a string";//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3
string str4 = str1;//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数
```

- 为了提高效率，允许编译器跳过创建临时对象这一步，直接调用构造函数构造要创建的对象，这样就完全等价于直接初始化了（语句1和语句3等价）
   - 当拷贝构造函数为private时：语句3和语句4在编译时会报错
   - 使用explicit修饰构造函数时：如果构造函数存在隐式转换，编译时会报错
### 25、初始化和赋值的区别
对于简单类型来说，初始化和赋值没什么区别
对于类和复杂数据类型来说，这两者的区别就大了
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678518443459-1881b75e-dc8e-4165-a87c-13c2e3f59a5d.png#averageHue=%23c6eccb&clientId=u5398f11f-4d36-4&from=paste&height=564&id=u6e68ed10&originHeight=846&originWidth=1272&originalType=binary&ratio=1&rotation=0&showTitle=false&size=83092&status=done&style=none&taskId=udf3dd1b5-c586-4c2a-90d2-133a201f06f&title=&width=848)
### 26、extern"C"的用法
**为了能够正确的在C++代码中调用C语言的代码：在程序中加上extern "C"后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++；**
**哪些情况下使用extern "C"：**

- C++代码中调用C语言代码；
- 在C++中的头文件中使用；
- 在多个人协同开发时，可能有人擅长C语言，而有人擅长C++；

### 27、野指针和悬空指针
**都是是指向无效内存区域(这里的无效指的是"不安全不可控")的指针，访问行为将会导致未定义行为。**

- 野指针

野指针，指的是没有被初始化过的指针，因此，为了防止出错，对于指针初始化时都是赋值为 nullptr，这样在使用时编译器就会直接报错，产生非法内存访问。

- 悬空指针

悬空指针，指针最初指向的内存已经被释放了的一种指针
```
int main(void) {
int * p = nullptr;   int* p2 = new int;
  p = p2;
  delete p2;
}
```
此时 p和p2就是悬空指针，指向的内存已经被释放。继续使用这两个指针，行为不可预料。需要设置为p=p2=nullptr。此时再使用，编译器会直接保错。
避免野指针比较简单，但悬空指针比较麻烦。c++引入了智能指针，**C++智能指针的本质就是避免悬空指针的产生。**

- **产生原因及解决办法：**
   - 野指针：指针变量未及时初始化 => 定义指针变量及时初始化，要么置空。
   - 悬空指针：指针free或delete之后没有及时置空 => 释放操作后立即置空。
### 28、C++中的重载、重写（覆盖）和隐藏的区别

- **重载**

重载是指在同一范围定义中的同名成员函数才存在重载关系。主要特点是函数名相同，参数类型和数目有所不同，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。重载和函数成员是否是虚函数无关
```
class A{
 ...
    virtual int fun();
    void fun(int);
    void fun(double, double);     static int fun(char);     ...
}
```

- **重写（覆盖）override**

重写指的是在派生类中覆盖基类中的同名函数，重写就是重写函数体，**要求基类函数必须是虚函数**且：

   - 与基类的虚函数有相同的参数个数
   - 与基类的虚函数有相同的参数类型
   - 与基类的虚函数有相同的返回值类型
```
//父类
class A{
public:
    virtual int fun(int a){} }
	//子类
class B : public A{
public:
	//重写,一般加override可以确保是重写父类的函数    
	virtual int fun(int a) override{}
}
```

- 重载与重写的区别
   - 重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系
   - 重写要求参数列表相同，重载则要求参数列表不同，返回值不要求
   - 重写关系中，调用方法根据对象类型决定，重载根据调用时实参表与形参表的对应关系来选择函数体
- **隐藏**

隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数，包括以下情况

   - 两个函数参数相同，但是基类函数不是虚函数。和重写的区别在于基类函数是否是虚函数。举个例子：

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678523423119-78230578-2a50-4a93-a60a-e39017d2c820.png#averageHue=%23c6eccb&clientId=u5398f11f-4d36-4&from=paste&height=582&id=u05fec552&originHeight=873&originWidth=780&originalType=binary&ratio=1&rotation=0&showTitle=false&size=71919&status=done&style=none&taskId=u16cb8d37-568a-4385-b154-b8dab58c570&title=&width=520)

   - 两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中。举个例子：

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678524039512-46886d56-6ff0-4e89-be95-6df989680596.png#averageHue=%23c6eccb&clientId=u5398f11f-4d36-4&from=paste&height=685&id=u12ff1257&originHeight=1028&originWidth=865&originalType=binary&ratio=1&rotation=0&showTitle=false&size=85521&status=done&style=none&taskId=ue59520a6-6778-44f5-9739-20bdf747255&title=&width=576.6666666666666)

### 29、C++有几种的构造函数

- 默认构造函数
```
Student(){//默认构造函数，没有参数
this->age = 20; 
this->num = 1000;
}

```

- 初始化构造函数（有参数）
```
Student(int a, int n):age(a), num(n){}; //初始化构造函数，有参数和参数列表
```

- 拷贝构造函数
```
Student(const Student& s){//拷贝构造函数，这里与编译器生成的一致
this->age = s.age; 
this->num = s.num;
}
```

- 移动构造函数（move和右值引用）

所谓移动语义，指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解，**移动构造函数指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。**
对于程序执行过程中产生的临时对象，往往只用于传递数据（没有其它的用处），并且会很快会被销毁。因此在使用临时对象初始化新对象时，我们可以将其包含的指针成员指向的内存资源直接移给新对象所有，无需再新拷贝一份，这大大提高了初始化的执行效率。

- 转换构造函数
```
Student(int r){   //转换构造函数,形参是其他类型变量，且只有一个形参
this->age = r;     
this->num = 1002;
}
```
**默认构造函数和初始化构造函数在定义类的对象，完成对象的初始化工作**
**拷贝构造函数用于复制本类的对象**
**转换构造函数用于将其他类型的变量，隐式转换为本类对象**

### 30、浅拷贝和深拷贝的区别

- 浅拷贝（有指针变量的话）

浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。

- 深拷贝	

深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的。

### 31、内联函数inline和宏定义的区别
**内联函数**

- 内联含函数比一般函数在前面多一个inline修饰符
- 内联函数是直接复制“镶嵌”到主函数中去的，就是将内联函数的代码直接放在内联函数的位置上，这与一般函数不同，主函数在调用一般函数的时候，是指令跳转到被调用函数的入口地址，执行完被调用函数后，指令再跳转回主函数上继续执行后面的代码；而由于内联函数是将函数的代码直接放在了函数的位置上，所以没有指令跳转，指令按顺序执行
- 一般函数的代码段只有一份，放在内存中的某个位置上，当程序调用它是，指令就跳转过来；当下一次程序调用它是，指令又跳转过来；而内联函数是程序中调用几次内联函数，内联函数的代码就会复制几份放在对应的位置上
- 内联函数一般在头文件中定义，而一般函数在头文件中声明，在cpp中定义

**内联函数与宏定义区别**

- 在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。
- 内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载。
- 宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义
- 内联函数有类型检测、语法判断等功能，而宏没有

### 32、public，protected和private访问和继承权限/public/protected/private的 区别？
**小总结**

- public的变量和函数在类的内部外部都可以访问。
- protected的变量和函数只能在类的内部和其派生类中访问。 
- private修饰的元素只能在类内访问。

**1、访问权限**
派生类可以继承基类中除了构造/析构、赋值运算符重载函数之外的成员，但是这些成员的访问属性在派生过程中也是可以调整的，三种派生方式的访问权限如下表所示：注意外部访问并不是真正的外部访问，而是在通过派生类的对象对基类成员的访问。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678532672630-58992089-5aa8-4403-a1ce-001a6ff32399.png#averageHue=%23b2cbe5&clientId=u5398f11f-4d36-4&from=paste&height=129&id=h3bUG&originHeight=194&originWidth=1341&originalType=binary&ratio=1&rotation=0&showTitle=false&size=54897&status=done&style=none&taskId=u553f145c-3b5c-4f7a-a866-cd2be25d31c&title=&width=894)
派生类对基类成员的访问形象有如下两种

- 内部访问：由派生类中新增的成员函数对从基类继承来的成员的访问
- 外部访问：在派生类外部，通过派生类的对象对从基类继承来的成员的访问         

**2、继承权限**

- **public继承**

公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，都保持原有的状态，而基类的私有成员任然是私有的，不能被这个派生类的子类所访问

- **protected继承**

保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元函数访问，基类的私有成员仍然是私有的，访问规则如下

- **private继承**

私有继承的特点是基类的所有公有成员和保护成员都成为派生类的私有成员，并不被它的派生类的子类所访问，基类的成员只能由自己派生类访问，无法再往下继承，
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678529286557-734dad6b-bd48-4b6c-badf-1fc554c42a2d.png#averageHue=%23bcd0e6&clientId=u5398f11f-4d36-4&from=paste&height=137&id=MAI6G&originHeight=205&originWidth=1349&originalType=binary&ratio=1&rotation=0&showTitle=false&size=68726&status=done&style=none&taskId=u6111e435-7210-4499-8081-2e393dadfea&title=&width=899.3333333333334)
### 33、如何用代码判断大小端存储？
例：32bit的数字0x12345678

- 大端存储：字数据的高字节存储在低地址中

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678533027661-adce9d3f-83b1-4033-ab1e-1304da6af150.png#averageHue=%23c6eccb&clientId=u5398f11f-4d36-4&from=paste&height=143&id=u38fcd550&originHeight=215&originWidth=1351&originalType=binary&ratio=1&rotation=0&showTitle=false&size=37517&status=done&style=none&taskId=u53253854-df6c-4965-b492-62839b67c05&title=&width=900.6666666666666)

- 小端存储：字数据的高字节存储在高地址中

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678533063767-ee2b4738-b1e3-4a2c-9bf2-0e94458f72b5.png#averageHue=%23c6eccb&clientId=u5398f11f-4d36-4&from=paste&height=139&id=u872bed97&originHeight=208&originWidth=1351&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32520&status=done&style=none&taskId=ub8ce7359-19a9-406d-ae6e-d7862601a14&title=&width=900.6666666666666)
了解了大小端存储的方式，如何在代码中进行判断呢？下面介绍两种判断方式：
```
int main()
{int a = 0x1234;
    //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分     char c = (char)(a);
    if (c == 0x12)
		cout << "big endian" << endl;
    else if(c == 0x34)
  	cout << "little endian" << endl;
}
//只会留下低地址的部分，如果低地址存放的是12，说明低地址存放高字节数据，
//是大端存储，否则为小端存储
```
### 34、volatile、mutable和explicit关键字的用法
**1、volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改**
volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，告诉编译器对该变量不做优化，都会直接从变量内存地址中读取数据，从而可以提供对特殊地址的稳定访问。如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象
**volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。**

- **volatile 指针**

volatile 指针和 const 修饰词类似，const 有常量指针和指针常量的说法，volatile 也有相应的概念

   - 修饰由指针指向的对象、数据是 const 或 volatile 的
```
const char* cpch;volatile char* vpch;
```

   - 指针自身的值——一个代表地址的整数变量，是 const 或 volatile 的：
```
char* const pchc;char* volatile pchv;
```

- **多线程下的volatile **

有些变量是用volatile关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，**该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中**。如果变量被装入寄存器，**那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执**行。volatile的意思是让编译器每次操作该变量时**一定要从内存中真正取出**，而不是使用已经存在寄存器中的值。

- **volatile用在如下的几个地方:**
   - 中断服务程序中修改的供其它程序检测的变量需要加volatile
   - 多任务环境下各任务间共享的标志应该加volatile
   - 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义

**2、mutable**

- **被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中**
- 我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要**在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被mutable来修饰，并且放在函数后后面关键字位置。**

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678545582778-8e54a589-9c7d-497b-a3dd-4f96632cde1c.png#averageHue=%23c6eccb&clientId=u5398f11f-4d36-4&from=paste&height=615&id=ubeac71af&originHeight=922&originWidth=1202&originalType=binary&ratio=1&rotation=0&showTitle=false&size=122825&status=done&style=none&taskId=u437b0d04-6973-44c1-a700-6b4912a3281&title=&width=801.3333333333334)
**3、explicit**
explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换，注意以下几点：

- explicit 关键字只能用于类内部的构造函数声明上
- explicit 关键字作用于单个参数的构造函数
- 被explicit修饰的构造函数的类，不能发生相应的隐式类型转换

### 35、什么情况下会调用拷贝构造函数
用类的一个实例化对象去初始化另一个对象的时候

- 函数的参数是类的对象时（非引用传递） ，**我理解的是参数拷贝实体，因而调用了拷贝构造,实现过程是**调用函数时先根据传入的实参产生临时对象，再用拷贝构造去初始化这个临时对象，在函数中与形参对应，函数调用结束后析构临时对象
- 函数的返回值是函数体内局部对象的类的对象时 ,此时虽然发生（Named return Value优化）NRV优化，但是由于返回方式是值传递，所以会在返回值的地方调用拷贝构造函数
```
A getClassA()//此时会发生拷贝构造函数的调用，虽然发生NRV优化，但是依然调用拷贝构造函数{
	A a;
	return a;
//产生临时对象，调用拷贝构造函数把返回对象拷贝给临时对象，函数执行完先析构局部变量，再析构临时对象，  
依然会调用拷贝构造函数
}
```
### 36、C++中有几种类型的new
**在C++中，new有三种典型的使用方法：plain new，nothrow new和placement new**

- **plain new**  言下之意就是普通的new，就是我们常用的new，在C++中定义如下：
```
void* operator new(std::size_t) throw(std::bad_alloc); 
void operator delete(void *) throw();
```
**因此plain new在空间分配失败的情况下，抛出异常std::bad_alloc而不是返回NULL，因此通过判断返回值是否为NULL是徒劳的**

- **nothrow new**

nothrow new在空间分配失败的情况下是不抛出异常，而是返回NULL，定义如下
```
void * operator new(std::size_t,const std::nothrow_t&) throw();
void operator delete(void*) throw();

//例子
char *p = new(nothrow) char[10e11];    
if (p == NULL) 
    {
    	cout << "alloc failed" << endl;
}

```

- **placement new**

这种new允许在一块已经分配成功的内存上重新构造对象或对象数组。placement new不用担心内存分配失败，因为它根本不分配内存，它做的唯一一件事情就是调用对象的构造函数，**使用placement new需要注意两点：**

   - palcement new的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组
   - placement new构造起来的对象数组，要**显式的调用他们的析构函数来销毁**（析构函数并不释放对象的内存），千万不要使用delete，**这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。**

### 37、C++的异常处理的方法

- **try、throw和catch关键字**

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678587298061-8fbfac26-b2b6-4458-b57a-a9ab86c467f6.png#averageHue=%23c6eccb&clientId=ue21f886c-9eef-4&from=paste&height=410&id=uaba1f07b&originHeight=615&originWidth=749&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=60859&status=done&style=none&taskId=ud1dbd1a4-c712-4662-8f8c-376733a0367&title=&width=499.3333333333333)
程序的执行流程是**先执行try包裹的语句块**，**如果执行过程中没有异常发生，则不会进入任何catch包裹的语句块，如果发生异常，则使用throw进行异常抛出，再由catch进行捕获**，throw可以抛出各种数据类型的信息，代码中使用的是数字，也可以自定义异常class。**catch根据throw抛出的数据类型进行精确捕获（不会出现类型转换），如果匹配不到就直接报错，可以使用catch(...)的方式捕获任何异常（不推荐）**。当然，如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以在catch里面再throw异常。

### 38、static的用法和作用？

1. **隐藏。（static函数，static变量均可）**

当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。**加上static之后则只能在本文件使用**

2. **static的第二个作用是保持变量内容的持久**

存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，**说到底static还是用来隐藏的。**

3. **static的第三个作用是默认初始化为0（static变量）**

其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。

4. **static的第四个作用：C++中的类成员声明static**
- 函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值
- 在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；
- 在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；
- **类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；**
- **在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。**

**类内**

- static成员变量必须要在类外进行初始化，**static修饰的变量先于对象存在**，所以static修饰的变量要在类外初始化；
- **由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针**。正因为没有this指针，所以**static类成员函数不能访问非static的类成员，只能访问 static修饰的类成员；**
- static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；**静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual**；虚函数的调用关系，this->vptr->ctable->virtual function

### 39、值传递、指针传递、引用传递的区别和效率

1. 值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象   或是大的结构体对象，将耗费一定的时间和空间。（传值）
2. 指针传递：同样有一个形参向函数所属的栈拷贝数据的过程，**但拷贝的数据是一个固定为4字节的地址**。（传值，传递的是地址值）
3. 引用传递：同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。（传地址）

**效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰。**
### 40、静态变量什么时候初始化
初始化只有一次，但是可以多次赋值，在主程序之前，编译器已经为其分配好了内存
**但是C和C++初始化节点有区别**

- 在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化，**所以我们看到在C语言中无法使用变量对静态局部变量进行初始化**，在程序运行结束，变量所处的全局内存会被全部回收。
- 而在C++中，初始化时在执行相关代码时才会进行初始化，主要是由于C++引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。**所以C++标准定为全局或静态对象是有首次用到时才会进行构造**，并通过atexit()来管理。**在程序结束按照构造顺序反方向进行逐个析构**。**所以在C++中是可以使用变量对静态局部变量进行初始化的。**

### 41、const关键字的作用有哪些?

- 阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；
- 对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量，类的常对象只能访问类的常成员函数；
- const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员；
- 非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；
- **声明为const的对象不允许调用非const成员函数**。因为非const成员函数会被看作是要修改对象中数据的函数，因此const对象只能调用const成员函数。
- **const类型变量可以通过类型转换符const_cast将const类型转换为非const类型**；
- **const类型变量必须定义的时候进行初始化**，因此也导致如果类的成员变量有const类型的变量，那么该变量必须在类的初始化列表中进行初始化；
- **只有引用传递和指针传递可以用是否加const来重载。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来。因为**对于函数值传递的情况，因为参数传递是通过复制实参创建一个临时变量传递进函数的，函数内只能改变临时变量，但无法改变实参。则这个时候无论加不加const对实参不会产生任何影响。但是在引用或指针传递函数调用中，因为传进去的是一个引用或指针，这样函数内部可以改变引用或指针所指向的变量，这时const 才是实实在在地保护了实参所指向的变量。

### 42、delete p、delete [] p、allocator都有什么作用？

- delete p 析构对象+内存释放 new是将内存分配与对象构造组合在一起
- delete[] p 数组中的元素按逆序的顺序进行销毁
- **allocator将这两部分分开进行**，allocator申请一部分内存，不进行初始化对象，只有当需要的时候才进行初始化操作。
### 43、malloc与free的实现原理？

1. 在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由**brk、mmap、，munmap这些系统调用实现的**;
2.  **brk是将数据段(.data)的最高地址指针_edata往高地址推**,**mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存**。这**两种方式分配的都是虚拟内存**，没有分配物理内存。在第一次**访问已分配的虚拟地址空间的时候，发生缺页中断**，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系；
3. **malloc小于128k的内存**，使用brk分配内存，**将_edata往高地址推**；**malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配**；brk分配的内存需要**等到高地址内存释放以后才能释 放 ，而mmap分配的内存可以单独释放**
4. **malloc是从堆里面申请内存，也就是说函数返回的指针是指向堆里面的一块内存**。操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。

### 44、malloc、realloc、calloc的区别

- malloc函数
```
void* malloc(unsigned int num_size);
int *p = malloc(20*sizeof(int));申请20个int类型的空间；
```

- calloc函数

省去了人为空间计算；malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的；
```
void* calloc(size_t n,size_t size);
int *p = calloc(20, sizeof(int));
```

- realloc函数

给动态分配的空间分配额外的空间，用于扩充容量。
```
void realloc(void *p, size_t new_size);
```


### 45、类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表 会快一些？

1. **类成员初始化方式：**
- **赋值初始化**，通过在函数体内进行赋值初始化

对于在函数体中初始化,是在所有的数据成员**被分配内存空间后**才进行的。

- **列表初始化**，在冒号后使用初始化列表进行初始化。

**列表初始化是给数据成员分配内存空间时就进行初始化,**列表初始化的数据成员要在冒号后面有括号赋值表达式。初始化这个数据成员时函数体还未执行

2. **一个派生类构造函数的执行顺序如下：**
   1. 虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）
   2. 基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）
   3. 类型的成员对象的构造函数（按照初始化顺序）
   4. 派生类自己的构造函数。
3. **赋值初始化**是在构造函数当中做赋值的操作，而**列表初始化**是做纯粹的初始化操作。我们都知道，C++的**赋值操作是会产生临时对象的。临时对象的出现会降低程序的效率。**
### 46、有哪些情况必须用到成员列表初始化？作用是什么？

1. 必须使用成员初始化的四种情况
- 当初始化一个引用成员时
- 当初始化一个常量成员时
- 当调用一个基类的构造函数，而它拥有一组参数时
- 当调用一个成员类的构造函数，而它拥有一组参数时
2. 成员初始化列表做了什么
- 编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码之前
- list中的初始化顺序是由类中的成员声明顺序决定的，不是由初始化列表的顺序决定的

### 47、C++中新增了string，它与C语言中的 char *有什么区别吗？它是如何 实现的？

- string继承自basic_string,其实是对char*进行了封装，封装的string包含了char*数组，容量，长度等等属性。
- string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2^n），然后将原字符串拷贝过去，并加上新增的内容。

### 48、什么是内存泄露，如何检测与避免

- 内存泄露

一般我们常说的**内存泄漏是指堆内存的泄漏**。堆内存是指程序从堆中分配的，大小任意的(内存块的大小可以在程序运行期决定)内存块，使用完后必须显式释放的内存。应用程序般**使用malloc,、realloc、 new等函数从堆中分配到块内存**，**使用完后，程序必须负责相应的调用free或delete释放该内存块**，**否则，这块内存就不能被再次使用，我们就说这块内存泄漏了**

- 避免内存泄露的几种方式
   - 计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露
   - 一定要将基类的析构函数声明为虚函数 
   - 对象数组的释放一定要用delete []
   - 有new就有delete，有malloc就有free，保证它们一定成对出现

### 49、对象复用的了解，零拷贝的了解

- 对象复用

对象复用其本质是一种设计模式：Flyweight享元模式。
通过将对象存储到“对象池”中实现对象的重复利用，这样可以避免多次创建重复对象的开销，节约系统资源。（**感觉线程池就是**）

- 零拷贝

零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。零拷贝技术可以减少数据拷贝和共享总线操作的次数。
在C++中，vector的一个**成员函数emplace_back()很好地体现了零拷贝技术**，它跟push_back()函数一样可以将一个元素插入容器尾部，区别在于：**使用push_back()函数需要调用拷贝构造函数和转移构造函数，而使用emplace_back()插入的元素原地构造，不需要触发拷贝构造和转移构造，效率更高**

### 50、介绍面向对象的三大特性，并且举例说明
**三大特性：继承、封装和多态**

1. **继承**

**让某种类型对象获得另一个类型对象的属性和方法**。它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展
常见的继承有三种方式：

- 实现继承：指使用基类的属性和方法而无需额外编码的能力
- 接口继承：指**仅使用属性和方法的名称、但是子类必须提供实现的能力**
- 可视继承：指子窗体（类）使用基窗体（类）的外观和实现代码的能力（C++里好像不怎么用）
2. **封装**

数据和代码捆绑在一起，避免外界干扰和不确定性访问。
**封装，也就是把客观事物封装成抽象的类**，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏，例如：将公共的数据或方法使用public修饰，而不希望被访问的数据或方法采用private修饰。

3. **多态**

同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为（**重载实现编译时多态，虚函数实现运行时多态**），允许将子类类型的指针赋值给父类类型的指针
**实现多态有二种方式：覆盖（override），重载（overload）**

   - 覆盖：是指子类重新定义父类的虚函数的做法。
   - 重载：是指允许存在多个同名函数，而这些函数的参数表不同


### 51、C++ 的 四 种 强 制 转 换 reinterpret_cast/const_cast/static_cast /dynamic_cast
1、reinterpret_cast
```
reinterpret_cast<type-id> (expression)
type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以用于类型之间进行强制转换。
```
2、const_cast
该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。**用法如下：**

   - 常量指针被转化成非常量的指针，并且仍然指向原来的对象
   - 常量引用被转换成非常量的引用，并且仍然指向原来的对象
   - const_cast一般用于修改底指针。如const char *p形式

3、static_cast
```
static_cast < type-id > (expression)

```
     该运算符把expression转换为type-id类型，**但没有运行时类型检查来保证转换的安全性**。它主要有如下几种用法：

- 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用引用的转换
   - 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的
   - 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的
- 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。
- 把空指针转换成目标类型的空指针
- 把任何类型的表达式转换成void类型
- **注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。**

4、dynamic_cast
**有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全**
dynamic_cast主要用于类层次间的**上行转换和下行转换**，还可以用于类之间的交叉转换
在类层次间进行**上行转换时，dynamic_cast和static_cast的效果是一样的**
在进行**下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全**
总结：**在进行下行转换时，dynamic_cast安全的，如果下行转换不安全的话其会返回空指针，这样在进行操作的时候可以预先判断**。而使用static_cast下行转换存在不安全的情况也可以转换成功，但是直接使用转换后的对象进行操作容易造成错误。

### 52、说说移动构造函数

- **移动构造函数出现的原因：**

我们用对象a初始化对象b，后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷

- **移动构造函数实现方法：**

拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制。浅层复制之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了。
**所以我们只要避免第一个指针释放空间就可以了。避免的方法就是将第一个指针（比如a->value）置为NULL，这样在调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收a->value指向的空间；**

- **移动构造函数的参数和move：**

移动构造函数的参数和拷贝构造函数不同，**拷贝构造函数的参数是一个左值引用**，**但是移动构造函数的初值是一个右值引用**。意味着，**移动构造函数的参数是一个右值或者将亡值的引用**。也就是说，**只有用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数**。而那个**move语句，就是将一个左值变成一个将亡值。**

### 53、如何获得结构成员相对于结构开头的字节偏移量
**使用<stddef.h>头文件中的，offsetof宏。**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678629160460-094f5526-700b-4f66-8e4e-b6a1aaa33fef.png#averageHue=%23c6eccb&clientId=ue21f886c-9eef-4&from=paste&height=413&id=ua2936c8b&originHeight=619&originWidth=761&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=47166&status=done&style=none&taskId=u33aa9225-76fe-454d-8984-c0af0ba7759&title=&width=507.3333333333333)


### 54、静态类型和动态类型，静态绑定和动态绑定的介绍

- 静态类型：对象在声明时采用的类型，在编译期既已确定；
- 动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；
- 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期
- 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期

从上面的定义也可以看出，**非虚函数一般都是静态绑定，而虚函数都是动态绑定（如此才可实现多态性）**
**静态类型就是定义时用什么类型去定义的，等号左边的定义类型**
**动态类型是指针实际指向的对象是什么类型，等号右边的类型**

- 不是虚函数的时候

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678673677928-5c95f1a9-c82d-45db-8782-0518019aebfd.png#averageHue=%23c6eccb&clientId=ue21f886c-9eef-4&from=paste&height=365&id=u59438cd7&originHeight=547&originWidth=1161&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=46529&status=done&style=none&taskId=u233630e0-da6b-46e5-8df0-6a857cbad68&title=&width=774)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678673701598-51c7c55f-34fe-419e-b4c1-a657250e6a89.png#averageHue=%23c6eccb&clientId=ue21f886c-9eef-4&from=paste&height=535&id=u8d75585e&originHeight=802&originWidth=1288&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=179180&status=done&style=none&taskId=ud8e486b8-6e24-4c48-9f00-ffbf27621d8&title=&width=858.6666666666666)

- 如果将A类中的virtual注释去掉，则运行结果是：

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678673803377-0eefc62b-d3f5-4124-9413-0b77b8054be5.png#averageHue=%23c6eccb&clientId=ue21f886c-9eef-4&from=paste&height=135&id=u02597d08&originHeight=202&originWidth=1289&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=73819&status=done&style=none&taskId=u0aec2418-18d1-4a9f-87cf-8c5acb0b0d4&title=&width=859.3333333333334)
**总结**
**上面的例子中**

- 如果基类A中的func不是virtual函数，那么不论pa、pb、pc指向哪个子类对象，**对func的调用都是在定义pa、pb、pc时的静态类型决定，早已在编译期确定了**。
- 同样的空指针也能够直接调用no-virtual函数而不报错（这也说明一定要做空指针检查啊！），**因此静态绑定不能实现多态；**
- 如果func是虚函数，那**所有的调用都要等到运行时根据其指向对象的类型才能确定**，比起静态绑定自然是要有性能损失的，但是却能实现多态特性；

**总结一下静态绑定和动态绑定的区别**

- 静态绑定发生在编译期，动态绑定发生在运行期；
- 对象的动态类型可以更改，但是静态类型无法更改；
- 要想实现多态，必须使用动态绑定；
- **在继承体系中只有虚函数使用的是动态绑定**，其他的全部是静态绑定；

### 55、引用是否能实现动态绑定，为什么可以实现？
引用在创建的时候必须初始化，**在访问虚函数时，编译器会根据其所绑定的对象类型决定要调用哪个函数**。**注意只能调用虚函数**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678674618787-3f9f8094-3455-4c5a-9ce2-d4a757315438.png#averageHue=%23c6eccb&clientId=ue21f886c-9eef-4&from=paste&height=765&id=u2957cfce&originHeight=1147&originWidth=1010&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=69128&status=done&style=none&taskId=ubd23813e-ec2c-4829-8e28-091b9ad11af&title=&width=673.3333333333334)
需要说明的是**虚函数才具有动态绑定**，上面代码中，Son类中还有一个非虚函数func()，这在b对象中是无法调用的，如果使用基类指针来指向子类也是一样的。

### 56、全局变量和局部变量有什么区别

- **生命周期不同**：全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在
- **使用方式不同**：通过声明后全局变量在程序的各个部分都可以用到；局部变量分配在堆栈区，只能在局部使用。
- 操作系统和编译器通过**内存分配的位置可以区分两者**，**全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 **。

### 57、指针加减计算需要注意什么？
指针加减本质是**对其所指地址的移动，移动的步长跟指针的类型是有关系的**，因此在涉及到指针加减运算需要十分小心，**加多或者减多都会导致指针指向一块未知的内存地址**，如果再进行操作就会很危险。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678675175335-6a795e08-2faf-4b4e-b1d8-c0cdce2ed98c.png#averageHue=%23c6eccb&clientId=ue21f886c-9eef-4&from=paste&height=413&id=uc0705354&originHeight=620&originWidth=1030&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=74780&status=done&style=none&taskId=ua62e919d-f7aa-4f8f-9d4b-8ea4c7b0858&title=&width=686.6666666666666)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678675193433-62b4bbcd-b125-4df5-8874-cb232958c976.png#averageHue=%23c6ecca&clientId=ue21f886c-9eef-4&from=paste&height=43&id=ua9fb22e0&originHeight=64&originWidth=1028&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=25815&status=done&style=none&taskId=u6e3a7aab-42d1-4d68-87d7-5392144d5ea&title=&width=685.3333333333334)
遇到指针的计算，**需要明确的是指针每移动一位，它实际跨越的内存间隔是指针类型的长度，建议都转成10进制计算，计算结果除以类型长度取得结果**

### 58、 怎样判断两个浮点数是否相等？
对两个浮点数判断大小和是否相等**不能直接用==来判断**，会出错！明明相等的两个数比较反而是不相等！**对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值**！**浮点数与0的比较也应该注意。与浮点数的表示方式有关。**

### 59、方法调用的原理（栈、汇编）

1. 机器用栈来传递过程参数、存储返回信息、保存寄存器用于以后恢复，以及本地存储。**而为单个过程分配的那部分栈称为帧栈**；**帧栈可以认为是程序栈的一段，它有两个端点，一个标识起始地址，一个标识着结束地址，两个指针结束地址指针esp，开始地址指针ebp;**
2. 由一系列栈帧构成，这些栈帧对应一个过程，而且每一个栈指针+4的位置存储函数返回地址；每一个栈帧都建立在调用者的下方，当被调用者执行完毕时，这一段栈帧会被释放。**由于栈帧是向地址递减的方向延伸，因此如果我们将栈指针减去一定的值，就相当于给栈帧分配了一定空间的内存**。**如果将栈指针加上一定的值，也就是向上移动，那么就相当于压缩了栈帧的长度，也就是说内存被释放了。**

由于栈是从高地址向低地址延申，也就是高地址是栈底，低地址是栈顶，因而栈指针减去一定的值，向栈顶移动，那就是分配了内存，反向就是释放了内存

3. **过程实现**




### 60、C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道 吗？

1. 指针参数传递本质上是值传递，它所传递的是一个地址值。
- 值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本（替身）
- 值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。
2. 引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间
- 但是这时存放的是由主调函数放进来的实参变量的地址。
- 被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）
- 因此，被调函数对形参的任何操作都会影响主调函数中的实参变量
3.  **引用传递和指针传递是不同的**，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。

而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。**如果想通过       指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用**

### 61、类如何实现只能静态分配和只能动态分配

1. 前者是把new、delete运算符重载为private属性。后者是把构造、析构函数设为protected属性，再用子类来动态创建
2. 建立类的对象有两种方式：
- 静态建立，静态建立一个类对象，就是由编译器为对象在栈空间中分配内存；
- 动态建立，A *p = new A();动态建立一个类对象，就是使用new运算符为对象在堆空间中分配内存。这个过程分为两步，第一步执行operator new()函数，在堆中搜索一块内存并进行分配；第二步调用类构造函数构造对象；
3. 只有使用new运算符，对象才会被建立在堆上，因此只要限制new运算符就可以实现类对象只能建立在栈上，可以将new运算符设为私有。

### 62、如果想将某个类用作基类，为什么该类必须定义而非声明？
**派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什么。所以必须定义而非声明。**

### 63、知道C++中的组合吗？它与继承相比有什么优缺点吗？

1. **继承**

继承是Is a 的关系，比如说Student继承Person,则说明Student is a Person。继承的优点是子类可以重写父类的方法来方便地实现对父类的扩展。
**继承的缺点有以下几点：**

- 父类的内部细节对子类是可见的。
- 子类从父类继承的方法在编译时就确定下来了，所以无法在运行期间改变从父类继承的方法的行为
- 如果对父类的方法做了修改的话（比如增加了一个参数），则子类的方法必须做出相应的修改。所以说子类与父类是一种高耦合，违背了面向对象思想。
2. **组合**

组合也就是设计类的时候把要组合的类的对象加入到该类中作为自己的成员变量。
**组合的优点：**

- 当前对象**只能通过所包含的那个对象去调用其方法**，所以**所包含的对象的内部细节对当前对象时不可见的**
- **当前对象与包含的对象是一个低耦合关系，如果修改包含对象的类中代码不需要修改当前对象类的代码**
- 当前对象可以在运行时动态的绑定所包含的对象。可以通过set方法给所包含对象赋值

**组合的缺点：**

- 容易产生过多的对象
- 为了能组合多个对象，必须仔细对接口进行定义

### 64、什么是函数指针？

1. 什么是函数指针？
- 函数指针指向的是特殊的数据类型，**函数的类型是由其返回的数据类型和其参数列表共同决定的**，而函数的名称则不是其类型的一部分
- 一个具体函数的名字，如果**后面不跟调用符号(即括号)，则该名字就是该函数的指针**(注意：大部分情况下，可以这么认为，但这种说法并不很严格)
2. **函数指针的声明方法**

int (*pf)(const int&, const int&);
上面的pf就是一个函数指针，指向所有返回类型为int，并带有两个const int&参数的函数。**注意*pf两边的括号是必须的**，否则上面的定义就变成了：
int *pf(const int&, const int&);
而这声明了一个函数pf，其返回类型为int *， 带有两个const int&参数。

3. ** 为什么有函数指针**

函数与数据项相似，函数也有地址。**我们希望在同一个函数中通过使用相同的形参在不同的时间使用产生不同的效果。**

4. 一个函数名就是一个指针，它指向函数的代码

**一个函数地址是该函数的进入点，也就是调用函数的地址。函数的调用可以通过函数名，也可以通过指向函数的指针来调用**。函数指针还允许将函数作为变元传递给其他函数

5. **函数指针两种方法赋值**

指针名 = 函数名；  指针名 = &函数名

### 65、说一说你理解的内存对齐

1. **一般内存对齐**
- 分配内存的顺序是按照声明的顺序
- 每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍，不是整数倍空出内存，直到偏移量是整数倍为止
- 最后整个结构体的大小必须是里面变量类型最大值的整数倍
2. **添加了#pragma pack(n)后规则就变成了下面这样**
- 偏移量要是n和当前变量大小中较小值的整数倍
- 整体大小要是n和最大变量大小中较小值的整数倍
-  n值必须为1,2,4,8…，为其他值时就按照默认的分配规则

### 66、函数调用过程栈的变化，返回值和参数变量哪个先入栈？

- 调用者函数把被调函数所需要的参数按照与被调函数的形参顺序相反的顺序压入栈中,即:从右向左依次把被调函数所需要的参数压入栈

**函数形参从右至左依次入栈**

- 在被调函数中,从ebp的位置处开始存放被调函数中的局部变量和临时变量,并且这些变量的地址按照定义时的顺序依次减小,即:这些变量的地址是按照栈的延伸方向排列的,先定义的变量先入栈,后定义的变量后入栈;

**函数中定义的变量，先定义的先入栈，后定义的后入。**

### 67、你知道printf函数的实现原理是什么吗？
在C/C++中，对函数参数的扫描是从后向前的。
**C/C++的函数参数是通过压入堆栈的方式来给函数传参数的（**堆栈是一种先进后出的数据结构），最先压入的参数最后出来，在计算机的内存中，数据有2块，一块是堆，一块是栈（函数参数及局部变量在这里），**而栈是从内存的高地址向低地址生长的，控制生长的就是堆栈指针了，最先压入的参数是在最上面，就是说在所有参数的最后面，最后压入的参数在最下面，结构上看起来是第一个，所以最后压入的参数总是能够被函数找到，因为它就在堆栈指针的上方。**
**printf的第一个被找到的参数就是那个字符指针，就是被双引号括起来的那一部分**，函数通过**判断字符串里控制参数的个数来判断参数个数及数据类型，通过这些就可算出数据需要的堆栈指针的偏移量了**printf("%d,%d",a,b);
最先找到双引号括起来参数是因为，函数形参是从右至左压入，而字符指针是最后压入的，也就是在栈顶，所以第一个被找到

### 68、cout和printf有什么区别？

- cout<<是一个函数，c**out<<后可以跟不同的类型是因为cout<<已存在针对各种类型数据的重载**，所以会自动识别数据的类型。输出过程会首先将**输出字符放入缓冲区，然后输出到屏幕**。**cout是有缓冲输出。**
-  **printf是无缓冲输出。有输出时立即输出**



### 69、全局变量和static变量的区别
全局变量之前加上static修饰就构成了静态的全局变量，**全局变量和静态全局变量都是静态存储方式**，**两者的区别在于作用域**：

- 非静态全局变量的作用域是整个源程序，当一个源程序由多个原文件组成时，非静态的全局变量在各个源文件中都是有效的
- 静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。static全局变量与普通的全局变量的区别是**static全局变量只初始化一次**，防止在其他文件单元被引用。

### 70、静态成员与普通成员的区别是什么？

1. **生命周期**
- **静态成员变量**从类被加载开始到类被卸载，一直存在
- **普通成员变量**只有在类创建对象后才开始存在，对象结束，它的生命期结束
2. **共享方式**
- 静态成员变量是全类共享
- 普通成员变量是每个对象单独享用的
3. **定义位置**
- 普通成员变量存储在栈或堆中
- 静态成员变量存储在静态全局区
4. **初始化位置**
- 普通成员变量在类中初始化
- 静态成员变量在类外初始化
5. **默认实参**

可以使用静态成员变量作为默认实参

### 71、说一下你理解的 ifdef endif代表着什么？

1. **条件编译**

一般情况下，源程序中所有的行都参加编译。但是有时**希望对其中一部分内容只在满足一定条件才进行编译，也就是对一部分内容指定编译的条件，这就是“条件编译”**。有时，希望当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句

2. 条件编译命令最常见的形式为：

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678688711029-40ff5732-f880-4cd7-ba02-d7064409c2ba.png#averageHue=%23c6eccb&clientId=ue21f886c-9eef-4&from=paste&height=307&id=ub32cc1f4&originHeight=460&originWidth=1029&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=40842&status=done&style=none&taskId=u8ad2311d-a338-4f2b-8cec-a1b21a87a13&title=&width=686)

3. 条件编译的作用：

在一个大的软件工程里面，可能会有多个文件同时包含一个头文件，当这些文件编译链接成一个可执行文件上时，就会出现大量“重定义”错误。**在头文件中使用#define、#ifndef、#ifdef、#endif能避免头文件重定义**

### 72、你知道strcpy和memcpy的区别是什么吗？

1. 复制的内容不同。**strcpy只能复制字符串**，而**memcpy可以复制任意内容**，例如字符数组、整型、结构体、类等。
2. 复制的方法不同。**strcpy不需要指定长度**，它**遇到被复制字符的串结束符"\0"才结束**，所以容易溢出。memcpy则是**根据其第3个参数决定复制的长度**
3. 用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy

### 73、程序在执行int main(int argc, char *argv[])时的内存结构，你了解 
参数的含义是程序在命令行下运行的时候，需**要输入argc 个参数，每个参数是以char 类型输入的，依次存在数组里面，数组是 argv[]**，**所有的参数在指针char * 指向的内存中，数组的中元素的个数为 argc 个，第一个参数为程序的名称**。

### 74、如果有一个空类，它会默认添加哪些函数？

1. Empty();** 缺省构造函数**
2. Empty( const Empty& )；**拷贝构造函数**
3. ~Empty();**析构函数**
4. Empty& operator=( const Empty& )；**赋值运算符**

### 75、C++中标准库是什么？

1.  C++ 标准库可以分为两部分：
- **标准函数库**： 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言
- **面向对象类库**： 这个库是类及其相关函数的集合
2. 输入/输出 I/O、字符串和字符处理、数学、时间、日期和本地化、动态分配、其他、宽字符函数
3. 标准的 C++ I/O 类、String 类、数值类、STL 容器类、STL 算法、STL 函数对象、STL 迭代器、STL分配器、本地化库、异常处理类、杂项支持库

### 76、你知道const char* 与string之间的关系是什么吗？
**string 是c++标准库里面其中一个，封装了对字符串的操作的STL容器**，实际操作过程我们可以用const char*给string类初始化
**char*和string和const char*之间的转化关系如下：**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678691826794-e591a133-d8e0-4327-b3b0-7777e3f0921b.png#averageHue=%23c5ebca&clientId=ue21f886c-9eef-4&from=paste&height=596&id=u99bca9c7&originHeight=894&originWidth=500&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=82699&status=done&style=none&taskId=ub5cb1635-a829-4e04-b1b3-8402f67092a&title=&width=333.3333333333333)

### 77、如何设计一个类计算子类的个数？

1. 为类设计一个static静态变量count作为计数器
2. 类定义结束后初始化count;
3. 在构造函数中对count进行+1
4. 设计拷贝构造函数，在进行拷贝构造函数中进行count +1操作
5. 设计复制构造函数，在进行复制函数中对count+1操作
6. 在析构函数中对count进行-1

### 78、将引用作为函数参数有哪些好处？
使用引用传递函数的参数，在内存中并**没有产生实参的副本，它是直接对实参操作**
而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本，如果传递的是对象，还将调用拷贝构造函数。因此，当**参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。**

### 79、如何阻止一个类被实例化？有哪些方法？

1. 将类定义为抽象基类或者将构造函数声明为private
2. 不允许类外部创建类对象，只能在类内部创建对象

### 80、你知道Denug和release的区别是什么吗？

1. **Debug是调试版本，包含调试信息，所以容量比Release大很多，并且不进行任何优化**（优化会使调试复杂化，因为源代码和生成的指令间关系会更复杂），便于程序员调试。Debug模式下生成两个文件，除了.exe或.dll文件外，还有一个.pdb文件，该文件记录了代码中断点等调试信息
2. **Release是发布版本，不对源代码进行调试，编译时对应用程序的速度进行优化**，**使得程序在代码大小和运行速度上都是最优的**。（调试信息可在单独的PDB文件中生成）。Release模式下生成一个文件.exe或.dll文件
3. 实际上，Debug 和 Release 并没有本质的界限，他们只是一组编译选项的集合，编译器只是按照预定的选项行动。事实上，我们甚至可以修改这些选项，从而得到优化过的调试版本或是带跟踪语句的发布版本。

### 81、成员函数里memset(this,0,sizeof(*this))会发生什么

1. 有时候类里面定义了很多int,char,struct等c语言里的那些类型的变量，我习惯在构造函数中将它们初始化为0，但是一句句的写太麻烦，**所以直接就memset(this, 0, sizeof *this);将整个对象的内存全部置为0**。对于这种情形可以很好的工作，但是下面几种情形是不可以这么使用的
2. 类含有**虚函数表指针**：这么做会破坏虚函数表指针，后续对虚函数的调用都将出现异常
3. 类中含有C++类型的对象：例如，类中定义了一个list的对象，由于在构造函数体的代码执行之前就对list对象完成了初始化，假设list在它的构造函数里分配了内存，那么我们这么一做就破坏了list对象的内存。

### 82、你知道回调函数吗？它的作用？

1. 当发生某种事件时，**系统或其他函数将会自动调用你定义的一段函数**
2. **回调函数就相当于一个中断处理函数，由系统在符合你设定的条件时自动调用**。为此，你需要做三件事：1，声明函数；2，定义函数；3，设置触发条件，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用
3. 回调函数就是一个**通过函数指针调用的函数**。如果你把**函数的指针（地址）作为参数传递给另一个函数**，**当这个指针被用为调用它所指向的函数时，我们就说这是回调函数**
4. 因为可以把调用者与被调用者分开。**调用者不关心谁是被调用者**，**所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为int）的被调用函数**



### 83、C++从代码到可执行程序经历了什么？

1. **预编译**

主要处理源代码文件中的以“#”开头的预编译指令
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678695798717-e9dc656e-9c22-4fbe-b150-518817ad1cf0.png#averageHue=%23c6eccb&clientId=ue21f886c-9eef-4&from=paste&height=193&id=ua6f8f242&originHeight=289&originWidth=993&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=81933&status=done&style=none&taskId=ueeee75a5-05f3-4ead-b94d-8869ad7fd8d&title=&width=662)

2. **编译**

把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应
的汇编代码文件。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678695898823-9dd156dd-2620-486b-8fcf-fc722a9b7d90.png#averageHue=%23c6eccb&clientId=ue21f886c-9eef-4&from=paste&height=287&id=u6727cb20&originHeight=431&originWidth=1030&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=125419&status=done&style=none&taskId=u72de725e-7d7d-4335-aeb5-31eecdcc663&title=&width=686.6666666666666)

3. **汇编**

将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows下)、xxx.obj(Linux下)

4. **链接**

将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：

- **静态链接**

函数和数据被编译进一个二进制文件。在编译链接可执行文件时，链接器从静态库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。

   - 空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；
   - 更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序
   - 运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快
- **动态链接**

**动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件**

   - 共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本
   - 更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标
   - 性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。
#### 
### 84、为什么友元函数必须在类内部声明？
因为编译器必须能够读取这个结构的声明以理解这个数据类型的所有规则。
有一条规则在任何关系中都很重要，那就是谁可以访问我的私有部分

### 85、友元函数和友元类的基本情况
友元提供了不同类的成员函数之间、类的成员函数和一般函数之间**进行数据共享的机制**。**通过友元，一个普通函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员**。**友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。**

1. 友元函数

友元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中声明所有可以访问它的友元函数
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678696596252-44bebb93-18bb-4fe3-b43b-27e5e54e8c34.png#averageHue=%23c6eccb&clientId=ue21f886c-9eef-4&from=paste&height=601&id=Q0b8q&originHeight=901&originWidth=923&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=55389&status=done&style=none&taskId=ua020af68-e367-4d46-825f-ec38fe08c97&title=&width=615.3333333333334)
**一个函数可以是多个类的友元函数，但是每个类中都要声明这个函数**

2. 友元类

友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。但是另一个类里面也要相应的进行声明
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678696719215-82e9de21-fe1c-4f13-92f5-665e4b6fd13f.png#averageHue=%23c6eccb&clientId=ue21f886c-9eef-4&from=paste&height=525&id=ud4c1cd48&originHeight=787&originWidth=870&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=50694&status=done&style=none&taskId=u55bf0207-25f2-4bef-ac2b-ca05d8e4508&title=&width=580)
使用友元类时应注意：

- **友元关系不能被继承**
- **友元关系是单向的**，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明
- **友元关系不具有传递性**。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明
3. 

## 

### 86 、为什么不能把所有的函数写成内联函数
内联函数以代码复杂为代价，**它以省去函数调用的开销来提高执行效率**。所以**一方面如果内联函数体内代码执行时间相比函数调用开销较大，则没有太大的意义**；另一方面**每一处内联函数的调用都要复制代码，消耗更多的内存空间，因此以下情况不宜使用内联函数：**

- 函数体内的代码比较长，将导致内存消耗代价
- 函数体内有循环，函数执行时间要比函数调用开销大

## 二、内存管理
### 1、类的对象存储空间受哪些因素影响？

- 类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小
- 编译器加入的额外成员变量（**如指向虚函数表的指针**）
- 内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的。
- 当该该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展

 **空类(无非静态数据成员)的对象的size为1, 当作为基类时, size为0. **
### 2、简要说明C++的内存分区
C++中的内存分区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区和代码区
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678764432479-1700994f-2f93-415d-abc9-568afbce2aaa.png#averageHue=%23eee9e0&clientId=ud88db8bb-44de-4&from=paste&height=455&id=u73cd7adb&originHeight=683&originWidth=577&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=312819&status=done&style=none&taskId=u8a5f8ff1-0e70-4d66-8127-007706c8ee5&title=&width=384.6666666666667)

- **栈**

**在执行函数时，函数内局部变量的存储单元都可以在栈上创建**，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限

- **堆**

**就是那些由 new分配的内存块，他们的释放编译器不去管**，由我们的应用程序去控制，一般一个new就要对应一个 delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收

- **自由存储区**

如果说堆是操作系统维护的一块内存，那么自由存储区就是C++中通过new和delete动态分配和释放对象的抽象概念。需要注意的是，**自由存储区和堆比较像，但不等价**

- **全局/静态存储区**

**全局变量和静态变量被分配到同一块内存中**，**在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的**，**在C++里面没有这个区分了，它们共同占用同一块内存区**，在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0

- **常量存储区**

这是一块比较特殊的存储区，这里面存放的是常量，不允许修改

- **代码区**

存放函数体的二进制代码

### 3、什么是内存池，如何实现
内存池（Memory Pool） 是一种**内存分配方式**。通常我们习惯直接使用**new、malloc 等申请内存，这样做的缺点在于：由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能**。内存池则是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块， 若内存块不够再继续申请新的内存。这样做的一个显著优点是尽量避免了内存碎片，使得内存分配效率得到提升。

### 4、C++中类的数据成员和成员函数内存分布情况
C++类是由结构体发展得来的，所以他们的成员变量（C语言的结构体只有成员变量）的内存分配机制是一样的。下面我们以类来说明问题，如果类的问题通了，结构体也也就没问题啦。 类分为成员变量和成员函数，我们先来讨论成员变量。

- 一个类对象的地址就是类所包含的这一片内存空间的首地址，这个首地址也就对应具体某一个成员变量的地址
- **对象的大小和对象中数据成员的大小是一致的**，也就是说，**成员函数不占用对象的内存**。**这是因为所有的函数都是存放在代码区的，不管是全局函数，还是成员函数**
- **静态成员函数与一般成员函数的唯一区别就是没有this指针**，因此不能访问非静态数据成员，**静态函数也放在代码区**

### 5、关于this指针你知道什么？全说出来

- **this指针是什么**
   - this指针是类的指针，指向对象的首地址
   - this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this
   - this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置
- **this指针的用处**
   - 一个对象的this指针并不是对象本身的一部分，不会影响 sizeof(对象) 的结果。
   - this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候（全局函数，静态函数中不能使用this指针），编译器会自动将对象本身的地址作为一个隐含参数传递给函数
   - 即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行
- **this指针的使用**
   - 一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this
   - 另外一种情况是当形参数与成员变量名相同时用于区分，如this->n = n （不能写成n = n）

### 6、内存泄漏的后果？如何监测？解决方法

- **内存泄漏**

**内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况**。内存泄漏并非指内存在物理上消失，而是应用程序分配某段内存后，**由于设计错误，失去了对该段内存的控制**

- ** 后果**

只发生一次小的内存泄漏可能不被注意，但**泄漏大量内存的程序将会出现各种征兆**：性能下降到内存逐渐用完，导致另一个程序失败

- **如何排除**

**调试运行DEBUG版程序**，运用以下技术：CRT(C run-time libraries)、运行时函数调用堆栈、内存泄漏时提示的内存分配序号(集成开发环境OUTPUT窗口)，综合分析内存泄漏的原因，排除内存泄漏

- **解决方法**

智能指针

- **检查、定位内存泄漏**

检查方法：在main函数最后面一行，**加上一句_CrtDumpMemoryLeaks()**。调试程序，自然关闭程序让其退出，查看输出：
**输出这样的格式**{453}normal block at 0x02432CA8,868 bytes long
被{}包围的453就是我们需要的内存泄漏定位值，868 bytes long就是说这个地方有868比特内存没有释放

### 7、在成员函数中调用delete this会出现什么问题？对象还可以使用吗？
**在类对象的内存空间中，只有数据成员和虚函数表指针**，并不包含代码内容，**类的成员函数单独放在代码段中**。在**调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它**。当调用delete this时，类对象的内存空间被释放。**在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行**。**一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题**

### 8、 如果在类的析构函数中调用delete this，会发生什么？
**会导致堆栈溢出**。原因很简单，**delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”**。显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，**形成无限递归，造成堆栈溢出，系统崩溃。**

### 9、空类的大小，以及类的大小探讨

- **空类的大小**

C++空类的大小不为0，不同编译器设置不一样，vs设置为1。因为C++标准指出，**不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址。当该空白类作为基类时**，该类的大小就优化为0了，子类的大小就是子类本身的大小。**这就是所谓的空白基类最优化**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678773088288-b4a9237b-b1e5-4e1f-8d55-a71df7f39188.png#averageHue=%23c6eccb&clientId=ud88db8bb-44de-4&from=paste&height=145&id=ud606f3f3&originHeight=217&originWidth=501&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=18106&status=done&style=none&taskId=udea6f12a-ebef-4479-a7ff-13855a649a1&title=&width=334)
空类同样可以被实例化，**并且每个实例在内存中都有独一无二的地址**，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址
**空类的实例大小就是类的大小**，所以sizeof(a)=1字节,**如果a是指针，则sizeof(a)就是指针的大小，即4字节。**

- **有虚函数的类的大小**

类中函数都放在代码区，理论上不算类的大小，但是**有虚函数的类对象中都有一个虚函数表指针 __vptr**，**其大小是4字节**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678773257214-a7fa747f-4326-433a-912a-aa836ce8c1fa.png#averageHue=%23c6eccb&clientId=ud88db8bb-44de-4&from=paste&height=146&id=u16dba10d&originHeight=219&originWidth=504&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=19393&status=done&style=none&taskId=u071d90ed-904d-41cc-80f0-9e490ffcdb3&title=&width=336)

- **静态成员存放在静态存储区，不占用类的大小**

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678773334633-5bbd9106-cf8e-45ac-bdc7-3f3cb5aa8f64.png#averageHue=%23c6eccb&clientId=ud88db8bb-44de-4&from=paste&height=327&id=ue2eb9761&originHeight=490&originWidth=545&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=40108&status=done&style=none&taskId=u51976409-78b7-4e6b-9205-b2cef83b21f&title=&width=363.3333333333333)


## 三、C++11新标准
### 1、C++11有哪些新特性

- nullptr替代 NULL
- 引入了 auto 和 decltype 这两个关键字实现了类型推导
- 基于范围的 for 循环for(auto& i : res){}
- 类和结构体的中初始化列表
- Lambda 表达式（匿名函数）
- std::forward_list（单向链表）
- 右值引用和move语义
- ...

### 2、auto、decltype和decltype(auto)的用法

- **auto,通过表达式的值，也就是初始值来推导**

C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型
auto 让编译器通过初始值来进行类型推演。从而获得定义变量的类型，**所以说 auto 定义的变量必须有初始值**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678774738718-1938c361-370d-4e87-bf24-1d59123fa2b8.png#averageHue=%23c6eccb&clientId=ud88db8bb-44de-4&from=paste&height=328&id=u9cf7a649&originHeight=492&originWidth=950&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=75154&status=done&style=none&taskId=uadba5ba7-b9a7-482e-b314-44b21fb7c88&title=&width=633.3333333333334)

- **decltype，仅通过表达式来推导**

有的时候我们还会遇到这种情况，**我们希望从表达式中推断出要定义变量的类型，但却不想用表达式的值去初始化变量**。还有可能是函数的返回类型为某表达式的值类型。在这些时候auto显得就无力了，所以C++11又引入了第二种类型说明符decltype，**它的作用是选择并返回操作数的数据类型。在此过程中，编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值。**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678774976643-7fb98875-7c5f-4df5-9320-4d58b39a413b.png#averageHue=%23c6eccb&clientId=ud88db8bb-44de-4&from=paste&height=705&id=u46195dd0&originHeight=1058&originWidth=985&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=166353&status=done&style=none&taskId=u61445558-c854-40ac-9cc5-2e33a98f805&title=&width=656.6666666666666)

- **decltype(auto)**

decltype(auto)是C++14新增的类型指示符，**可以用来声明变量以及指示函数返回类型**。在使用时，**会将 “=”号左边的表达式替换掉auto**，再根据decltype的语法规则来确定类型。举个例子
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678775171773-294281e6-7cdd-4ca8-935a-ae3c54c45b8c.png#averageHue=%23c6eccb&clientId=ud88db8bb-44de-4&from=paste&height=75&id=u97cb365c&originHeight=112&originWidth=834&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=17139&status=done&style=none&taskId=uc3811ac9-bfbe-46ea-919b-117e4f7734f&title=&width=556)

### 3、C++中NULL和nullptr的区别

- **需要区分NULL和nullptr的原因**

NULL来自C语言，一般由宏定义实现，而 **nullptr 则是C++11的新增关键字**。**在C语言中**，NULL被定义为(void*)0,而在C++语言中，**NULL则被定义为整数0**。
在C++中指针必须有明确的类型定义。**但是将NULL定义为0带来的另一个问题是无法与整数的0区分**。**因为C++中允许有函数重载，**所以可以试想如下函数定义情况：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678775561025-6a045555-93b2-4e4f-9aeb-c29b01717e8b.png#averageHue=%23c6eccb&clientId=ud88db8bb-44de-4&from=paste&height=281&id=u3c3ca34e&originHeight=421&originWidth=573&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=22274&status=done&style=none&taskId=u33aac6da-c74d-4ff3-8a1e-af311dcee1a&title=&width=382)
那么在传入NULL参数时，会把NULL当做整数0来看，如果我们想调用参数是指针的函数，该怎么办呢

- **nullptr在C++11被引入用于解决这一问题**，**nullptr可以明确区分整型和指针类型**，**能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误。**由于nullptr是明确的指针类型，所以不会与整形变量相混淆
- 但是nullptr仍有问题，例如

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678775874725-bf3a60fe-8a4c-46df-9148-b7d5c21812a9.png#averageHue=%23c6eccb&clientId=ud88db8bb-44de-4&from=paste&height=451&id=uff1a2e7b&originHeight=676&originWidth=527&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=44867&status=done&style=none&taskId=u1d9b25c3-d920-4163-9a82-873592a3d57&title=&width=351.3333333333333)
**在这种情况下存在对不同指针类型的函数重载**，此时如果**传入nullptr指针则仍然存在无法区分应实际调用哪个函数，这种情况下必须显示的指明参数类型。**

### 4、智能指针的原理、常用的智能指针及实现
**智能指针是一个类**，**用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏**。动态分配的资源，交给一个类对象去管理，**当类对象声明周期结束时，自动调用析构函数释放资源**
**常用的智能指针**

1. **shared_ptr**

**实现原理**：采用引用计数器的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，**当计数为0的时候会自动的释放动态分配的资源**

- 智能指针将一个计数器与类指向的对象相关联，引用计数器跟踪共有多少个类对象共享同一指针
- 每次创建类的新对象时，初始化指针并将引用计数置为1
- 当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数
- 对一个对象进行赋值时，赋值操作符**减少左操作数所指对象**的引用计数（如果引用计数为减至0，则删除对象），并增加**右操作数所指对象的引用计数 （就是一个共享指针本来指向对象a，突然改了赋值指向b，那么原来指向的对象a的引用计数--，新指向的对象b引用计数++）**
- 调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）
2. **unique_ptr**

unique_ptr采用的是**独享所有权语义**，**一个非空的unique_ptr总是拥有它所指向的资源**。**转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空**
所以unique_ptr不支持普通的拷贝和赋值操作，不能用在STL标准容器中；**局部变量的返回值除外（因为编译器知道要返回的对象将要被销毁）。**如果你拷贝一个unique_ptr，那么拷贝结束后，**这两个unique_ptr都会指向相同的资源，造成在结束时对同一内存指针多次释放而导致程序崩溃**

3. **weak_ptr弱引用**

引用计数有一个问题就是**互相引用形成环（环形引用）**，这样两个指针指向的内存都无法释放。**需要使用weak_ptr打破环形引用。**
weak_ptr是一个**弱引用**，**它是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，它只引用，不计数**
如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，**在使用之前使用函数lock()检查weak_ptr是否为空指针**

4. **auto_ptr**

主要是为了解决“**有异常抛出时发生内存泄漏**”的问题 。因为发生异常而无法正常释放内存
auto_ptr有**拷贝语义，拷贝后源对象变得无效，这可能引发很严重的问题**；而unique_ptr则无拷贝语义，但提供了移动语义，这样的错误不再可能发生，因为很明显必须使用std::move()进行转移
auto_ptr不支持拷贝和赋值操作，不能用在STL标准容器中。STL容器中的元素经常要支持拷贝、赋值操作，在这过程中auto_ptr会传递所有权，所以不能在STL中使用

### 5、说一说你了解的关于lambda函数的全部知识

1. 利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象
2. 每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类当然重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，其实一个右值。所以，我们上面的lambda表达式的结果就是一个个闭包。**闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为lambda捕捉块。**
3. lambda表达式的语法定义如下：

**[capture] （parameters） mutable ->return-type {statement};**

4. lambda必须使用尾置返回来指定返回类型，可以忽略参数列表和返回值，但必须永远包含捕获列表和函数体；






### 6、说说你了解的auto_ptr的作用



### 7、智能指针的循环引用
**循环引用是指使用多个智能指针share_ptr时，出现了指针之间相互指向，从而形成环的情况**，有点**类似于死锁的情况**，这种情况下，智能指针往往不能正常调用对象的析构函数，从而造成内存泄漏。举个例子：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678777741165-5f455a62-9619-43be-bdde-4f129ffb212c.png#averageHue=%23c6eccb&clientId=ud88db8bb-44de-4&from=paste&height=655&id=u49033a66&originHeight=983&originWidth=479&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=67161&status=done&style=none&taskId=ucdeedc4d-de21-4efb-9d09-4a7e1f8498a&title=&width=319.3333333333333)
从上面shared_ptr的实现中我们知道了只有当引用计数减减之后等于0，析构时才会释放对象，而上述情况造成了一个僵局，那就是**析构对象时先析构sp2,可是由于sp2的空间sp1还在使用中**，**所以sp2.use_count减减之后为1，不释放，sp1也是相同的道理，由于sp1的空间sp2还在使用中，所以sp1.use_count减减之后为1**，也不释放。sp1等着sp2先释放，sp2等着sp1先释放,二者互不相让，导致最终都没能释放，内存泄漏。
在实际编程过程中，应该尽量避免出现智能指针之前相互指向的情况，如果不可避免，**可以使用使用弱指针——weak_ptr，它不增加引用计数，只要出了作用域就会自动析构。弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。**

### 8、std::move()
C++11的标准库 <utility> 提供了一个非常有用的函数 std::move()，std::move() 函数将一个左值强制转化为右值引用，以用于移动语义
移动语义，允许直接转移对象的资产和属性的所有权，而在参数为右值时无需复制它们。
换一种说法就是，std::move() 将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝

比如下面这个例子，原str（lvalue值）被moved from之后值被转移，所以为空字符串
```cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;

int main()
{
    string str = "hello";
    cout << "before str: " << str << endl;

    vector<string> vstr;
    vstr.emplace_back(std::move(str));
    cout << "after  str: " << str << endl;

    return 0;
}
```


### 9、std::forward()
std::forward被称为**完美转发**，它的作用是保持原来的值属性不变。啥意思呢？通俗的讲就是，如果原来的值是左值，经std::forward处理后该值还是左值；如果原来的值是右值，经std::forward处理后它还是右值
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1683527446554-f9a2d461-e5e7-4acc-aa30-b784778303ea.png#averageHue=%23f5f4f4&clientId=u4c8e6446-de49-4&from=paste&height=723&id=u89b7cb8a&originHeight=1084&originWidth=1080&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=83932&status=done&style=none&taskId=uc7baeb05-a107-4454-b9e0-d99647619d7&title=&width=720)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1683527471927-228eefa0-c75c-4bc9-8ffa-a1dd95ad5eda.png#averageHue=%23f4f2f1&clientId=u4c8e6446-de49-4&from=paste&height=509&id=u5ff1b17a&originHeight=763&originWidth=1062&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=151829&status=done&style=none&taskId=ueafe6262-b3ec-4c1f-aafc-45da4eb2228&title=&width=708)
## 四、STL模板库
### 1、什么是STL？
C++ STL从广义来讲包括了三类：**算法，容器和迭代器**

- 算法包括排序，复制等常用算法，以及不同容器特定的算法
- 容器就是数据的存放形式，包括序列式容器和关联式容器，序列式容器就是list，vector等，关联式容器就是set，map等
- 迭代器就是在不暴露容器内部结构的情况下对容器的遍历

### 2、使用智能指针管理内存资源，RAII是怎么回事？

- RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”，也就是说在构造函数中申请分配资源，在析构函数中释放资源。

**因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数**。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。

- 智能指针（std::shared_ptr和std::unique_ptr）即RAII最具代表的实现，**使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。**

毫不夸张的来讲，有了智能指针，代码中几乎不需要再出现delete了

### 3、迭代器：++it、it++哪个好，为什么

- 前置返回一个引用，后置返回一个对象

++i返回的是一个左值，因为++i是先加之后再使用变量，因而是变量先增加，然后返回该变量，这样返回的就是一个左值
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678796566922-cbeffd70-5d8c-43b4-8c43-486ac6388f6c.png#averageHue=%23c6eccb&clientId=ud88db8bb-44de-4&from=paste&height=228&id=uaaec3e87&originHeight=342&originWidth=419&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=15524&status=done&style=none&taskId=uf295b812-356f-422f-970e-a02613d45d7&title=&width=279.3333333333333)

- 前置不会产生临时对象，**后置必须产生临时对象**，临时对象会导致效率降低

i++返回的是一个右值，因为i++是先使用再++，因而会先创建一个临时变量，将i的值赋给临时变量，然后i再++，返回这个临时变量
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678796647761-d614b6f0-7df7-45a9-bfef-8b80bd58122d.png#averageHue=%23c6eccb&clientId=ud88db8bb-44de-4&from=paste&height=253&id=u8764bae7&originHeight=379&originWidth=421&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=18071&status=done&style=none&taskId=ubc1263a5-5464-4ce2-8b9a-e99ec7c4d0e&title=&width=280.6666666666667)



### 4、说一下C++左值引用和右值引用
C++11正是通过引入右值引用来优化性能，具体来说是**通过移动语义来避免无谓拷贝的问题**，**通过move语义来将临时生成的左值中的资源无代价的转移到另外一个对象中去**，通过完美转发来解决不能按照参数实际类型来转发的问题（同时，完美转发获得的一个好处是可以实现移动语义）

1. 在C++11中所有的值必属于左值、右值两者之一，**右值又可以细分为纯右值、将亡值**。在C++11中**可以取地址的、有名字的就是左值**，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）
2. C++11对C++98中的右值进行了扩充。**在C++11中右值又分为纯右值（prvalue，Pure Rvalue）和将亡值（xvalue，eXpiring Value）**。其中**纯右值**的概念等同于我们在C++98标准中右值的概念，**指的是临时变量和不跟对象关联的字面量值**；**将亡值则是C++11新增的跟右值引用相关的表达式，这样表达式通常是将要被移动的对象（移为他用）**，比如返回**右值引用T&&的函数返回值**、**std::move的返回值**，或者**转换为T&&的类型转换函数的返回值。**将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。**在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。**
3. 左值引用就是对**一个左值进行引用的类型**。右值引用就是**对一个右值进行引用的类**型，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。右值引用和左值引用都是属于引用类型。**无论是声明一个左值引用还是右值引用，都必须立即进行初始化**。而其原因可以理解为是**引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名**。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。**左值引用通常也不能绑定到右值**，但**常量左值**引用是个“万能” 的引用类型。**它可以接受非常量左值、常量左值、右值对其进行初始化**。不过常量左值所引用的**右值在它的“余生”中只能是只读的**。相对地，**非常量左值只能接受非常量左值对其进行初始化**
4. 右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值。

- **左值和右值**

**左值**：表示的是可以获取地址的表达式，它能出现在赋值语句的左边，对该表达式进行赋值。但是修饰符const的出现使得可以声明如下的标识符，它可以取得地址，但是没办法对其进行赋值
const int& a = 10;
**右值**：表示无法获取地址的对象，有常量值、函数返回值、lambda表达式等。无法获取地址，但不表示其不可改变，当定义了右值的右值引用时就可以更改右值。

- **左值引用和右值引用**

**左值引用**：传统的C++中引用被称为左值引用
**右值引用**：C++11中增加了右值引用，**右值引用关联到右值时，右值被存储到特定位置**，右值引用指向该特定位置，也就是说，**右值虽然无法获取地址，但是右值引用是可以获取地址的，该地址表示临时对象的存储位置**
**这里主要说一下右值引用的特点：**

   - 通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，**只要该变量还活着，该右值临时量将会一直存活下去**
   - 右值引用独立于左值和右值。意思是**右值引用类型的变量可能是左值也可能是右值**
   - T&& t在发生自动类型推断的时候，它是左值还是右值取决于它的初始化
   - 举个例子

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678798832084-404e374d-e13e-4a2c-8c8a-b96c94146209.png#averageHue=%23c6eccb&clientId=ud88db8bb-44de-4&from=paste&height=677&id=ue0cab776&originHeight=778&originWidth=876&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=133449&status=done&style=none&taskId=u497e7a26-665e-4659-bfb8-893aa219734&title=&width=762)

### 6、STL的两级空间配置器
**首先明白为什么需要二级空间配置器？**
我们知道动态开辟内存时，要在堆上申请，但若是我们需要频繁的在堆开辟释放内存，则就会在堆上造成很多外部碎片，浪费了内存空间；每次都要进行调用malloc、free函数等操作，使空间就会增加一些附加信息，降低了空间利用率；随着外部碎片增多，内存分配器在找不到合适内存情况下需要合并空闲块，浪费了时间，大大降低了效率。
**于是就设置了二级空间配置器，当开辟内存<=128bytes时，即视为开辟小块内存，则调用二级空间配置器。**
关于STL中一级空间配置器和二级空间配置器的选择上，**一般默认选择的为二级空间配置器。 如果大于128字节再转去一级配置器。**

- **一级配置器**

一级空间配置器中重要的函数就是allocate、deallocate、reallocate **。 一级空间配置器是以malloc()， free()，realloc()等C函数执行实际的内存配置 **。大致过程是

   - 直接allocate分配内存，其实就是malloc来分配内存，成功则直接返回，失败就调用处理函数
   - 如果用户自定义了内存分配失败的处理函数就调用，没有的话就返回异常
   - 如果自定义了处理函数就进行处理，完事再继续分配试试
   - ![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678799377345-ce74f803-87b2-4ab8-b9f6-9834a14ace21.png#averageHue=%23f7f5f3&clientId=ud88db8bb-44de-4&from=paste&height=556&id=u99ed92ad&originHeight=834&originWidth=830&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=105124&status=done&style=none&taskId=ud532c178-6e4b-4e07-b49a-91e2677d2c7&title=&width=553.3333333333334)
- **二级配置器**

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678799420291-a917b433-4666-48cd-b428-1552d6984c0b.png#averageHue=%23f5f4f4&clientId=ud88db8bb-44de-4&from=paste&height=361&id=u8cd1ec25&originHeight=542&originWidth=836&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=103181&status=done&style=none&taskId=u7fbd09db-1f45-42cd-8f06-0664d46bc5a&title=&width=557.3333333333334)

   - 有个自动调整的函数：你传入一个字节参数，表示你需要多大的内存，会**自动帮你校对到第几号链表（0-15号链表，最小8字节 最大128字节）**
   - allocate函数：**如果要分配的内存大于128字节，就转用第一级分配器**，否则也就是小于128字节。那么**首先判断落在第几号链表**，定位到了，先判断链表是不是空，如果是空就需要充值，（**调节到8的倍数，默认一次申请20个区块，当然了也要判断20个是不是能够申请到，如果只申请到一个那就直接返回好了，不止一个的话，把第2到第n个挨个挂到当前链表上，第一个返回回去给容器用,n是不大于20的，当**然了如果不在1-20之间，那就是内存碎片了，那就先把碎片挂到某一条链表上，然后再重新malloc了， malloc  2*20个块）去内存池去拿或者重新分配。不为空的话
- **allocator，deallocator分配流程**

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678806018209-9331b716-2499-4072-b8a0-4126479f01e7.png#averageHue=%23c5ebc9&clientId=uef7529c9-2c3b-4&from=paste&height=227&id=u85cb82c8&originHeight=340&originWidth=870&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=121224&status=done&style=none&taskId=u0780f565-0b77-448a-86ab-0e7869f40d9&title=&width=580)


### 7、vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素

1. **vector数据结构**
- vector和数组类似，**拥有一段连续的内存空间**，并且起始地址不变。**因此能高效的进行随机存取，时间复杂度为o(1);但因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)**
- **当数组中内存空间不够时，会重新申请一块内存空间并进行内存拷贝**。连续存储结构：**vector是可以实现动态增长的对象数组，支持对数组高效率的访问和在数组尾端的删除和插入操作，在中间和头部删除和插入相对不易，需要挪动大量的数据**。它与数组最大的区别就是vector不需程序员自己去考虑容量问题，**库里面本身已经实现了容量的动态增长**，而数组需要程序员手动写入扩容函数进形扩容
2. **list数据结构**
- list是由双向链表实现的，**因此内存空间是不连续的。只能通过指针访问数据**，**所以list的随机存取非常没有效率，时间复杂度为o(n)**
- 但由于链表的特点，能高效地进行插入和删除
- 非连续存储结构：**list是一个双链表结构，支持对链表的双向遍历**。每个节点包括三个信息：元素本身，指向前一个元素的节点（prev）和指向下一个元素的节点（next）。**因此list可以高效率的对数据元素任意位置进行访问和插入删除等操作**。由于涉及对额外指针的维护，所以开销比较大。
3. **区别：**
- vector的**随机访问效率高，但在插入和删除时（不包括尾部）需要挪动数据，不易操作。**

访问倒数第二个元素 int mySize = vec.size();vec.at(mySize -2);

- list的访问要遍历整个链表，它的随机访问效率低。但对数据的插入和删除操作等都比较方便，改变指针的指向即可  **list不提供随机访问，所以不能用下标直接访问到某个位置的元素，要访问list里的元素只能遍历，不过你要是只需要访问list的最后N个元素的话，可以用反向迭代器来遍历**

### 8、STL 中vector分配的空间用完时，为什么是两倍扩容？
不同的编译器，vector有不同的扩容大小。在vs下是1.5倍，在GCC下是2倍
空间和时间的权衡。简单来说， 空间分配的多，平摊时间复杂度低，但浪费空间也多
**使用k=2增长因子的问题在于，每次扩展的新尺寸必然刚好大于之前分配的总和，也就是说，之前分配的内存空间不可能被使用**。这样对内存不友好。最好把增长因子设为(1,2)
 	对比可以发现采用采用成倍方式扩容，**可以保证常数的时间复杂度**，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容

### 9、Vector如何释放空间?
由于vector的内存占用空间只增不减，比如你首先分配了10,000个字节，然后erase掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个。所有内存空间是在vector析构时候才能被系统回收。 empty()用来检测容器是否为空的，clear()可以清空所有元素。但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。
**如果需要空间动态缩小，可以考虑使用deque**。**如果vector，可以用swap()来帮助你释放内存**
vector(Vec).swap(Vec); //将Vec的内存清除；
vector().swap(Vec); //清空Vec的内存；

## 

### 11、STL迭代器如何实现

-  迭代器是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器，**除此之外，STL中迭代器一个最重要的作用就是作为容器与STL算法的粘合剂**
- 迭代器的作用就是提供一个**遍历容器内部所有元素的接口**，因此迭代器内部必须保存一个与容器相关联的指针，然后重载各种运算操作来遍历，其中最重要的是*运算符与->运算符，以及++、--等可能需要重载的运算符重载。这和C++中的智能指针很像，智能指针也是将一个指针封装，然后通过引用计数或是其他方法完成自动释放内存的功能。
- 最常用的迭代器的相应型别有五种：value type、difference type、pointer、reference、iterator catagoly

### 12、map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为 什么使用红黑树？

- 他们的底层都是以**红黑树的结构实现**，因此**插入删除等操作都在O(logn)时间内完成**，因此可以完成高效的插入删除
- 在这里我们定义了一个模版参数，**如果它是key那么它就是set**，**如果它是map，那么它就是map**；底层是红黑树，实现**map的红黑树的节点数据类型是key+value，而实现set的节点数据类型是value**
- 因为map和set**要求是自动排序的**，**红黑树能够实现这一功能**，而且时间复杂度比较低。

### 13、map插入方式有哪几种？

- **用insert函数插入pair数据**

mapStudent.insert(pair<int, string>(1, "student_one"));

- **用insert函数插入value_type数据**

mapStudent.insert(map<int, string>::value_type (1, "student_one"));

- **在insert函数中使用make_pair()函数**

mapStudent.insert(make_pair(1, "student_one"));

- **用数组方式插入数据**

mapStudent[1] = "student_one";

### 14、STL中unordered_map(hash_map)和map的区别，hash_map如何解决 冲突以及扩容
**区别：**

- unordered_map和map类似，都是存储的key-value的值，可以通过key快速索引到value。**不同的是unordered_map不会根据key的大小进行排序**
- 存储时是根据key的hash值判断元素是否相同，即unordered_map内部元素是无序的，而map中的元素是按照二叉搜索树存储，进行中序遍历会得到有序遍历
- 所以使用时map 的key 需要定义**operator<** 。而unordered_map 需要定义hash_value 函数并且重载operator==。但是很多系统内置的数据类型都自带这些
- 那么**如果是自定义类型**，那么就需要自己重载operator<或者hash_value()了
- 如果需要内部元素自动排序，使用map，不需要排序使用unordered_map

**如何解决冲突：**
unordered_map的底层实现是**hash_table**; hash_map底层使用的是hash_table，**而hash_table使用的开链法进行冲突避免，所有hash_map采用开链法进行冲突解决**
**扩容：**

- **什么时候扩容**：当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值---即当前数组的长度乘以加载因子的值的时候，就要自动扩容啦
- 扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。

### 15、map中[]与find的区别？

- map的下标运算符[]的作用是：**将关键码作为下标去执行查找，并返回对应的值**；
- map的find函数：用关键码执行查找，**找到了返回该位置的迭代器**；**如果不存在这个关键码，就返回尾迭代器。**

### 16、STL中list与queue之间的区别

- list不再能够像vector一样以普通指针作为迭代器，因为其节点不保证在存储空间中连续存在
- list插入操作和结合操作都不会造成原有的list迭代器失效;
- list不仅是一个双向链表，而且还是一个环状双向链表，所以它只需要一个指针
- list**不像vector那样有可能在空间不足时做重新配置、数据移动的操作**，**所以插入前的所有迭代器在插入操作之后都仍然有效**
- deque是一种**双向开口的连续线性空间，所谓双向开口，意思是可以在头尾两端分别做元素的插入和删除操作**；
- deque和vector最大的差异，一在于deque允许常数时间内对起头端进行元素的插入或移除操作，二在于deque没有所谓容量概念，**因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，deque没有所谓的空间保留功能**

### 17、常见容器性质总结
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678806107932-c4145b63-2ccd-4d4a-9ff8-b3c789c8ec42.png#averageHue=%23c5ebca&clientId=uef7529c9-2c3b-4&from=paste&height=658&id=ubdcb491d&originHeight=987&originWidth=924&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=204169&status=done&style=none&taskId=uc65dc14c-a8be-40b8-9ece-5502ec88419&title=&width=616)

### 18、说一下STL每种容器对应的迭代器
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678806243125-a91d068c-f5cb-4319-8b28-3afba62b0e75.png#averageHue=%23c6eccb&clientId=uef7529c9-2c3b-4&from=paste&height=240&id=u27305a6e&originHeight=255&originWidth=875&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=27254&status=done&style=none&taskId=ud3849919-d00c-4b09-ae63-59a235ba70d&title=&width=822.328125)

### 19、STL中迭代器失效的情况有哪些
以vector为例

1. **插入元素**
- 尾后插入：size < capacity时，首迭代器不失效尾迭代失效（未重新分配空间），size == capacity时，所有迭代器均失效（需要重新分配空间）
- 中间插入：中间插入：size < capacity时，**首迭代器不失效但插入元素之后所有迭代器失效**，**size == capacity时，所有迭代器均失效**
2. **删除元素**
- 尾后删除：只有尾迭代失效。
- 中间删除：删除位置之后所有迭代失效。

**其他容器**

-  deque 和 vector 的情况类似
- 而list双向链表每一个节点内存不连续, 删除节点仅当前迭代器失效,erase返回下一个有效迭代器
- map/set等**关联容器底层是红黑树删除节点不会影响其他节点的迭代器**, 使用递增方法获取下一个迭代器 mmp.erase(iter++)
- unordered_(hash) 迭代器意义不大, rehash之后, 迭代器应该也是全部失效

### 20、STL中vector的实现
vector是一种序列式容器，**其数据安排以及操作方式与array非常类似**，两者的唯一差别就是对于空间运用的灵活性，众所周知，**array占用的是静态空间，一旦配置了就不可以改变大小**，如果遇到空间不足的情况**还要自行创建更大的空间，并手动将数据拷贝到新的空间中，再把原来的空间释放**
vector则使用灵活的动态空间配置，维护一块连续的线性空间**，在空间不足时，可以自动扩展空间容纳新元素，做到按需供给**。其在扩充空间的过程中仍然需要经历：**重新配置空间，移动数据，释放原空间等操作**。这里需要说明一下动态扩容的规则：**以原大小的两倍配置另外一块较大的空间**（或者旧长度+新增元素的个数）
需要注意的是，频繁对vector调用push_back()对性能是有影响的，这是因为每插入一个元素，如果空间够用的话还能直接插入，**若空间不够用，则需要重新配置空间，移动数据，释放原空间等操作，对程序性能会造成一定的影响**

### 21、STL中list的实现
相比于vector的连续线型空间，list显得复杂许多，**但是它的好处在于插入或删除都只作用于一个元素空间，因此list对空间的运用是十分精准的，对任何位置元素的插入和删除都是常数时间**。list不能保证节点在存储空间中连续存储，也拥有迭代器，迭代器的“++”、“--”操作对于的是指针的操作，list提供的迭代器类型是双向迭代器：Bidirectional iterators
**list节点的结构见如下源码**：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678845039944-a9d94d40-e3bb-4d75-bd89-d6d5e2b5c576.png#averageHue=%23c6eccb&clientId=uef7529c9-2c3b-4&from=paste&height=125&id=ufde0171e&originHeight=187&originWidth=354&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=13985&status=done&style=none&taskId=u8566c0d1-ce20-483d-890f-63c2a2a4f92&title=&width=236)
从源码可看出list显然是一个双向链表。**list与vector的另一个区别是，在插入和接合操作之后，都不会造成原迭代器失效，而vector可能因为空间重新配置导致迭代器失效**。
此外list也是一个环形链表，因此只要一个指针便能完整遍历整个链表。list中node节点指针始终指向尾端的一个空白节点，因此是一种“前闭后开”的区间结构
list的空间管理默认采用alloc作为空间配置器，为了方便的以节点大小为配置单位，还定义一个list_node_allocator函数可一次性配置多个节点空间
由于list的双向特性，**其支持在头部（front)和尾部（back)两个方向进行push和pop操作**，当然还支持erase，splice，sort，merge，reverse，sort等操作，

### 22、STL中deque的实现
vector是单向开口（尾部）的连续线性空间，deque**则是一种双向开口的连续线性空间**，虽然vector也可以在头尾进行元素操作，**但是其头部操作的效率十分低下（主要是涉及到整体的移动）**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678845387209-2b7fd2f8-6944-4f4e-a7ec-28887aab8a48.png#averageHue=%23e5e5e5&clientId=uef7529c9-2c3b-4&from=paste&height=144&id=u1ccd94f4&originHeight=216&originWidth=791&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=46567&status=done&style=none&taskId=u3c527313-d30d-4750-a54c-b59acbf87f0&title=&width=527.3333333333334)
deque和vector的最大差异一个是**deque运行在常数时间内对头端进行元素操作**，二是d**eque没有容量的概念，它是动态地以分段连续空间组合而成，可以随时增加一段新的空间并链接起来**
deque虽然也提供随机访问的迭代器，但是**其迭代器并不是普通的指针，其复杂程度比vector高很多**，因此除非必要，否则一般使用vector而非deque。如果**需要对deque排序，可以先将deque中的元素复制到vector中，利用sort对vector排序，再将结果复制回deque**
deque由一段一段的定量连续空间组成，**一旦需要增加新的空间，只要配置一段定量连续空间拼接在头部或尾部即可，因此deque的最大任务是如何维护这个整体的连续性**

- **deque的数据结构如下：**

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678845514702-3c43e819-f930-45bf-9b46-41145790eef1.png#averageHue=%23f1f1f0&clientId=uef7529c9-2c3b-4&from=paste&height=725&id=u6693fb79&originHeight=1088&originWidth=858&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=146568&status=done&style=none&taskId=u36729e2f-203f-486d-baae-e91ac5e24fa&title=&width=572)
deque**内部有一个指针指向map，map是一小块连续空间**，**其中的每个元素称为一个节点，node，每个node都是一个指针，指向另一段较大的连续空间**，**称为缓冲区**，**这里就是deque中实际存放数据的区域，默认大小512bytes。整体结构如上图所示**

- **deque的迭代器数据结构如下：**

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678845578434-70bb1cb0-8baa-42f0-ae42-ae042699027a.png#averageHue=%23c6eccb&clientId=uef7529c9-2c3b-4&from=paste&height=152&id=u5561df21&originHeight=228&originWidth=549&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=28955&status=done&style=none&taskId=u1e215240-835f-4cee-ae68-1e4ad0ed592&title=&width=366)
从deque的迭代器数据结构可以看出，**为了保持与容器联结，迭代器主要包含上述4个元素**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678845630069-475f8e6c-5a91-4032-90b7-6f976e4b1317.png#averageHue=%23f3f3f3&clientId=uef7529c9-2c3b-4&from=paste&height=318&id=u3a5eb3dd&originHeight=477&originWidth=847&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=62691&status=done&style=none&taskId=u412f342f-6ea8-41c5-b90e-e866ea28489&title=&width=564.6666666666666)
**deque迭代器的“++”、“--”操作是远比vector迭代器繁琐，其主要工作在于缓冲区边界**，如何从当前缓冲区跳到另一个缓冲区，当然deque内部在插入元素时，**如果map中node数量全部使用完，且node指向的缓冲区也没有多余的空间，这时会配置新的map（2倍于当前+2的数量）来容纳更多的node**，也就是可以指向更多的缓冲区。**在deque删除元素时，也提供了元素的析构和空闲缓冲区空间的释放等机制**

### 23、STL中stack和queue的实现

- **stack**

stack（栈）是一种先进后出（First In Last Out）的数据结构，只有一个入口和出口，那就是栈顶，除了获取栈顶元素外，没有其他方法可以获取到内部的其他元素
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678845742400-12b71dfb-1faa-4897-b7a1-53ab62697eb5.png#averageHue=%23dfdfdf&clientId=uef7529c9-2c3b-4&from=paste&height=130&id=u0fca2ded&originHeight=195&originWidth=707&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=27782&status=done&style=none&taskId=ue04a766d-8717-485f-8789-3e777634167&title=&width=471.3333333333333)
**stack这种单向开口的数据结构很容易由双向开口的deque和list形成**，只需要根据stack的性质对应移除某些接口即可实现
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678846062434-ce92bf21-4f91-4cef-9d4d-fdbcb56db537.png#averageHue=%23c6eccb&clientId=uef7529c9-2c3b-4&from=paste&height=232&id=uac65fb55&originHeight=348&originWidth=540&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=40131&status=done&style=none&taskId=ue6323df9-3eb6-4748-8412-de6ea86af1a&title=&width=360)
从stack的数据结构可以看出，**其所有操作都是围绕Sequence完成，而Sequence默认是deque数据结构**。 **stack这种“修改某种接口，形成另一种风貌”的行为，成为adapter(配接器)**。常将其归类为container adapter而非container
**stack除了默认使用deque作为其底层容器之外，也可以使用双向开口的list，只需要在初始化stack时，将list作为第二个参数即可**。**由于stack只能操作顶端的元素，因此其内部元素无法被访问，也不提供迭代器**。

- **queue**

queue（队列）是一种**先进先出（First In First Out）的数据结构**，只有一个入口和一个出口，分别位于最底端和最顶端，出口元素外，没有其他方法可以获取到内部的其他元素，其结构图如下
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678846295836-db1450d8-9b6f-4aee-8b95-0d2251b06101.png#averageHue=%23e8e8e8&clientId=uef7529c9-2c3b-4&from=paste&height=146&id=uac203f56&originHeight=219&originWidth=842&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=25355&status=done&style=none&taskId=u709e34b8-d3c8-4762-b05c-10371df8772&title=&width=561.3333333333334)
类似的，**queue这种“先进先出”的数据结构很容易由双向开口的deque和list形成**，只需要根据queue的性质对应移除某些接口即可实现，queue的源码如下
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678846322243-97faff48-2c3a-413d-b4c9-f2bebd0be364.png#averageHue=%23c6eccb&clientId=uef7529c9-2c3b-4&from=paste&height=241&id=ue9aafde8&originHeight=362&originWidth=561&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=39859&status=done&style=none&taskId=ue3fe159c-aac8-4ab7-98dd-1f82df2c8fa&title=&width=374)
从queue的数据结构可以看出，**其所有操作都也都是是围绕Sequence完成，Sequence默认也是deque数据结构。queue也是一类container adapter**
同样，**queue也可以使用list作为底层容器，不具有遍历功能，没有迭代器**

### 24、STL中的priority_queue的实现
大小顶堆：
何为大根堆？顾名思义，大根堆即指在逻辑上的二叉树结构中，根结点>子结点，总是最大的，并且在堆的每一个局部都是如此。例如{3,1,2}可以看作为大根堆，而{3,2,1}亦可以看作为大根堆。大根堆的根结点在整个堆中是最大的元素
priority_queue，优先队列，**是一个拥有权值观念的queue，它跟queue一样是顶部入口，底部出口**，在插入元素时，元素并非按照插入次序排列
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678846696793-dca183e3-2717-48a7-8db0-8dc9991fb844.png#averageHue=%23e2e2e2&clientId=uef7529c9-2c3b-4&from=paste&height=172&id=u25d36d21&originHeight=258&originWidth=844&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=66521&status=done&style=none&taskId=u2de9f47e-abb9-4afa-b1a0-2f3f7d45ab4&title=&width=562.6666666666666)
默认情况下，**priority_queue使用一个max-heap完成**，**底层容器使用的是一般为vector为底层容器**，**堆heap为处理规则来管理底层容器实现** 。**priority_queue的这种实现机制导致其不被归为容器，而是一种容器配接器**。关键的源码如下
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678846840203-d0aabcd9-d781-4048-9b73-7f7e8f07cef5.png#averageHue=%23c6eccb&clientId=uef7529c9-2c3b-4&from=paste&height=625&id=ub0c823df&originHeight=673&originWidth=778&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=63215&status=done&style=none&taskId=uf689d399-88c8-4c94-a712-935e25afd83&title=&width=722.65625)
priority_queue的所有元素，进出都有一定的规则，**只有queue顶端的元素（权值最高者）**，**才有机会被外界取用，它没有遍历功能，也不提供迭代器**
### 25、STL中set的实现？
STL中的容器可分为**序列式容器（sequence）和关联式容器（associative）**，**set属于关联式容器**
set的特性是，**所有元素都会根据元素的值自动被排序（默认升序），set元素的键值就是实值，实值就是键值，set不允许有两个相同的键值**
set不允许迭代器修改元素的值，**其迭代器是一种constance iterators**
**标准的STL set以RB-tree（红黑树）作为底层机制**，几乎所有的set操作行为都是转调用RB-tree的操作行为，这里补充一下红黑树的特性

- 每个节点不是红色就是黑色
- 根结点为黑色
- 如果节点为红色，其子节点必为黑
- 任一节点至（NULL）树尾端的任何路径，所含的黑节点数量必相同

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678847062728-f94498de-168d-465f-bd57-a2a605bac156.png#averageHue=%23c6eccb&clientId=uef7529c9-2c3b-4&from=paste&height=787&id=uca5102dd&originHeight=1181&originWidth=1006&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=92603&status=done&style=none&taskId=u504c7884-69fe-42d4-842a-21a39bc2ff8&title=&width=670.6666666666666)
**关联式容器尽量使用其自身提供的find()函数查找指定的元素，效率更高**，**因为STL提供的find()函数是一种顺序搜索算法**

### 26、STL中map的实现
map的特性是**所有元素会根据键值进行自动排序**。map中**所有的元素都是pair，拥有键值(key)和实值(value)两个部分，并且不允许元素有相同的key**
一旦map**的key确定了，那么是无法修改的**，**但是可以修改这个key对应的value**，因此map的迭代器既不是constant iterator，也不是mutable iterator
**标准STL map的底层机制是RB-tree（红黑树），另一种以hash table为底层机制实现的称为hash_map**。 map的架构如下图所示
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678847218600-24c146f2-991b-4021-b2f8-709995ce6b98.png#averageHue=%23e3e3e3&clientId=uef7529c9-2c3b-4&from=paste&height=516&id=u94b5493f&originHeight=774&originWidth=725&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=211526&status=done&style=none&taskId=u8802c87c-54e8-4389-8c6d-420f9c46a1b&title=&width=483.3333333333333)
map的在构造时缺省采用递增排序key，也使用alloc配置器配置空间大小，**需要注意的是在插入元素时，调用的是红黑树中的insert_unique()方法**，而非insert_euqal()（multimap使用）
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678847260028-e3fb6a5e-1ca3-4306-8e26-64001d33c3a9.png#averageHue=%23c6eccb&clientId=uef7529c9-2c3b-4&from=paste&height=890&id=ud3c0cb34&originHeight=1099&originWidth=808&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=93462&status=done&style=none&taskId=u76f87ff2-64b3-4559-924e-25525909515&title=&width=654.65625)
需要注意的是**subscript（下标）操作既可以作为左值运用（修改内容）也可以作为右值运用（获取实值）**
**例子：**
maps["abc"] = 1; //左值运用int num = maps["abd"]; //右值运用

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678847485693-22793aa0-7e49-4609-ac42-312f615500d8.png#averageHue=%23c6eccb&clientId=uef7529c9-2c3b-4&from=paste&height=530&id=ue9975437&originHeight=674&originWidth=895&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=118029&status=done&style=none&taskId=u6c2a43d5-d7e4-4b76-be03-7bccb58f7e4&title=&width=703.65625)

### 27、set和map的区别，multimap和multiset的区别

- **set和map的区别**

set**只提供一种数据类型的接口，但是会将这一个元素分配到key和value上**，**而且它的compare_function用的是 identity()函数，这个函数是输入什么输出什么**，这样就实现了set机制，set的key和value其实是一样的了。**其实他保存的是两份元素，而不是只保存一份元素**
map则提供两种数据类型的接口，分别放在key和value的位置上**，他的比较function采用的是红黑树的comparefunction（），保存的确实是两份元素。**
**他们两个的insert都是采用红黑树的insert_unique() 独一无二的插入 **

- **multimap和map的区别**

multimap和map的唯一区别就是：**multimap调用的是红黑树的insert_equal(),可以重复插入，**而**map调用的则是独一无二的插入insert_unique()**，multiset和set也一样，**底层实现都是一样的，只是在插入的时候调用的方法不一样。**
### 28、红黑树概念
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678847790089-1cc59e0c-3062-4ed2-adf9-08da1a6b57a7.png#averageHue=%23c6eccb&clientId=uef7529c9-2c3b-4&from=paste&height=542&id=ubcc7f5e5&originHeight=511&originWidth=745&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=78979&status=done&style=none&taskId=u28b7b718-0d6d-4071-b51c-5bf86687014&title=&width=789.65625)

### 29、STL中unordered_map和map的区别和应用场景

- **map支持键值的自动排序，底层机制是红黑树，红黑树的查询和维护时间复杂度均为$O(logn)**$，但是空间占用比较大，因为每个节点要保持父节点、孩子节点及颜色的信息
- **unordered_map是C++ 11新添加的容器，底层机制是哈希表**，**通过hash函数计算元素位置，其查询时间复杂度为O(1)**，维护时间与bucket桶所维护的list长度有关，但是建立hash表耗时较大
-  从两者的底层机制和特点可以看出：**map适用于有序数据的应用场景，unordered_map适用于高效查询的应用场景**

### 30、hashtable中解决冲突有哪些方法？

- **线性探测**

使用hash函数计算出的位置如果已经有元素占用了，则向后依次寻找，找到表尾则回到表头，直到找到一个空位

- **开链**

 每个表格维护一个list，如果hash函数计算出的格子相同，则按顺序存在这个list中

- **再散列**

 发生冲突时使用另一种hash函数再计算一个地址，直到不冲突

-  二次探测

使用hash函数计算出的位置如果已经有元素占用了，按照$1^2$、$2^2$、$3^2$...的步长依次寻找，如果步长是随机数序列，则称之为伪随机探测

- 公共溢出区

一旦hash函数计算的结果相同，就放入公共溢出区

### 31、堆为什么能用数组表示
堆是一种完全二叉树，但是否就意味着我们真的要用树来表示它呢？答案是否定的，因为完全二叉树有其非常卓越的性质：**对于任意一个父节点的序号n来说（这里n从0算），它的子节点的序号一定是2n+1,2n+2**，因此我们可以直接用数组来表示一个堆
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1683526499309-bd152b69-902e-45ec-a5b2-9e3b0ab3929d.png#averageHue=%23f8f7f7&clientId=u4c8e6446-de49-4&from=paste&height=461&id=u34edf707&originHeight=691&originWidth=813&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=178200&status=done&style=none&taskId=ua6d05b67-80f1-4945-97fa-03c0c4876df&title=&width=542)

## 五、其余问题

### 1、C++的多态是如何实现的
**C++的多态性，一言以蔽之就是**
在**基类的函数前加上virtual关键字**，**在派生类中重写该函数，运行时将会根据所指对象的实际类型来调用相应的函数，如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数。**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678858943705-44d31d5e-0db5-4961-96d0-531a1cfeab30.png#averageHue=%23c6eccb&clientId=uef7529c9-2c3b-4&from=paste&height=767&id=u241e4319&originHeight=851&originWidth=824&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=54451&status=done&style=none&taskId=u46f46e07-3a09-4fb5-a310-abbeb59bbff&title=&width=742.328125)
例子中，Base为基类，其中的函数为虚函数。子类1继承并重写了基类的函数，子类2继承基类但没有重写基类的函数，从**结果分析子类体现了多态性，那么为什么会出现多态性，其底层的原理是什么**？**这里需要引出虚函数表和虚函数表指针的概念**

- **虚表**：**虚函数表的缩写，类中含有virtual关键字修饰的方法时，编译器会自动生成虚表**
- **虚表指针**：在含有虚函数的类实例化对象时，对象地址的前四个字节存储的指向虚表的指针

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678859160560-f71cd9aa-9543-419a-b762-e24330b70a71.png#averageHue=%23f3e7c1&clientId=uef7529c9-2c3b-4&from=paste&height=499&id=u90dc0f65&originHeight=749&originWidth=730&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=203964&status=done&style=none&taskId=u2d840341-1076-4268-9b2e-53f20b94b16&title=&width=486.6666666666667)
**上图中展示了虚表和虚表指针在基类对象和派生类对象中的模型，下面阐述实现多态的过程**：

1. 编译器在**发现基类中有虚函数时**，会**自动为每个含有虚函数的类生成一份虚表**，该表是一个一维数组，虚表里保存了虚函数的入口地址
2. **编译器会在每个对象的前四个字节中保存一个虚表指针，即vptr，指向对象所属类的虚表**。在构造时，**根据对象的类型去初始化虚指针vptr，从而让vptr指向正确的虚表**，从而在调用虚函数时，能找到正确的函数
3. **所谓的合适时机，在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化**。在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表
4. 当派**生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表**；**当派生类对基类的虚函数重写时**，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面

**这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数重写情况动态的进行调用，从而实现多态性。**

### 2、为什么析构函数一般写成虚函数

- **C++中基类采用virtual虚析构函数是为了防止内存泄漏**

由于类的多态性，**基类指针可以指向派生类的对象**，如果**删除该基类的指针，就会调用该指针指向的派生类析构函数**，而**派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放**
如果**析构函数不被声明成虚函数**，则**编译器实施静态绑定**，在**删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数**，**这样就会造成派生类对象析构不完全，造成内存泄漏**
**所以将析构函数声明为虚函数是十分必要的**。**在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生，要将基类的析构函数声明为虚函数**
**具体地说：**如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。
**假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定**，**因而只会调用基类的析构函数，而不会调用派生类的析构函数**
那么在这种情况下，**派生类中申请的空间就得不到释放从而产生内存泄漏**

- 基类的析构函数不为虚函数

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678860362200-c5a44151-fcc7-4f00-aba5-a9ef621b10e2.png#averageHue=%23c6eccb&clientId=uef7529c9-2c3b-4&from=paste&height=559&id=u899066e5&originHeight=838&originWidth=617&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=56321&status=done&style=none&taskId=u81372fde-5780-43db-994b-debeebb9855&title=&width=411.3333333333333)

- **将基类的析构函数声明为虚函数**

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678860399390-a9a03a35-6abb-48f9-a790-40bed8d4b9bd.png#averageHue=%23c6eccb&clientId=uef7529c9-2c3b-4&from=paste&height=653&id=u6775acd3&originHeight=979&originWidth=821&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=62576&status=done&style=none&taskId=u7709d13e-be4b-4a28-bde8-4621f5cfc1f&title=&width=547.3333333333334)
但存在一种特例，在CRTP模板中，不应该将析构函数声明为虚函数，理论上所有的父类函数都不应该声明为虚函数，因为这种继承方式，不需要虚函数表。

### 3、构造函数能否声明为虚函数或者纯虚函数，析构函数呢？

- **析构函数：**
   - 析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。
   - 只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据，**为了防止内存泄漏**。
   - **析构函数可以是纯虚函数**，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。
- **构造函数：**
   - **构造函数不能定义为虚函数**。在构造函数中可以调用虚函数，不过此时调用的是正在构造的类中的虚函数，而不是子类的虚函数，因为此时子类尚未构造好。
   - **虚函数对应一个vtable(虚函数表)，类中存储一个vptr指向这个vtable**。**如果构造函数是虚函数，就需要通过vtable调用，可是对象没有初始化就没有vptr，无法找到vtable，所以构造函数不能是虚函数**

### 4、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间

- **虚函数表的特征：**
   - 虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成
   - 虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即**虚函数表不是函数，不是程序代码，不可能存储在代码段**
   - 虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而**类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定,即大小是在编译时期确定的**，**不必动态分配内存空间存储虚函数表，所以不在堆中**

根据以上特征，**虚函数表类似于类中静态成员变量.静态成员变量也是全局共享**，大小确定，因**此最有可能存在全局数据区。**
**C++中虚函数表位于只读数据段（.rodata）**，**也就是C++内存模型中的常量区**；而**虚函数则位于代码段（.text），也就是C++内存模型中的代码区**

### 5、模板函数和模板类的特例化
**引入原因：**
编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化
**定义：**
对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上
**1.模板函数特例化**
必须为原函数模板的每个模板参数都提供实参，**且使用关键字template后跟一个空尖括号对<>，表明将原模板的所有模板参数提供实参**，举例如下：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678861146337-aaa263a3-ea61-4e9d-9a1b-931e6a966658.png#averageHue=%23c6eccb&clientId=uef7529c9-2c3b-4&from=paste&height=355&id=uf118ea62&originHeight=336&originWidth=633&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=41665&status=done&style=none&taskId=u5fea8ed7-0c7d-4a16-bcee-5d2bdbce1d0&title=&width=669)

- **本质**

**特例化的本质是实例化一个模板，而非重载它**。特例化不影响参数匹配。**参数匹配都以最佳匹配为原则。例如，此处如果是compare(3,5)，则调用普通的模板，若为compare(“hi”,”haha”)则调用特例化版本**（因为这个cosnt char*相对于T，更匹配实参类型），注意二者函数体的语句不一样了，实现不同功能

- **注意**

模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本。
**2.类模板特例化**
原理类似函数模板，不过在类中，我们可以对模板进行特例化，也可以对类进行部分特例化。对类进行特例化时，仍然用template<>表示是一个特例化版本，例如：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678861639184-a239e01e-b2bf-4c0e-ae2c-0c89d45f6527.png#averageHue=%23c6eccb&clientId=uef7529c9-2c3b-4&from=paste&height=179&id=u73273580&originHeight=216&originWidth=814&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=33688&status=done&style=none&taskId=ubf13ef14-4b66-4c0f-bab7-19eea0450da&title=&width=674.65625)

- **类模板的部分特例化**

不必为所有模板参数提供实参，**可以指定一部分而非所有模板参数**，一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其**特例化版本中未指定的模板参数提供实参**(特例化时类名一定要和原来的模板相同，只是参数类型不同，按最佳匹配原则，哪个最匹配，就用相应的模板)
特例化类中的部分成员
可以特例化类中的部分成员函数而不是整个类，举个例子：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678861762938-b6b1df28-71e8-4d97-b558-eebf203f9086.png#averageHue=%23c6eccb&clientId=uef7529c9-2c3b-4&from=paste&height=587&id=ue36c487d&originHeight=484&originWidth=561&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=48861&status=done&style=none&taskId=u94fb5b82-3f9c-415b-b182-26e4021ea14&title=&width=680)

### 6、构造函数、析构函数、虚函数可否声明为内联函数
**首先，将这些函数声明为内联函数，在语法上没有错误**。**因为inline同register一样，只是个建议，编译器并不一定真正的内联。**
**register关键字**：这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率 
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678862000652-76166efe-97a6-4964-bebc-ac022f6caa86.png#averageHue=%23c6eccb&clientId=uef7529c9-2c3b-4&from=paste&height=749&id=u91f064cf&originHeight=831&originWidth=812&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=48753&status=done&style=none&taskId=u79bfacee-fe6d-4393-a74a-501cd2fe93e&title=&width=732.328125)

- **构造函数和析构函数声明为内联函数是没有意义的**

《Effective C++》中所阐述的是：**将构造函数和析构函数声明为inline是没有什么意义的，即编译器并不真正对声明为inline的构造和析构函数进行内联操作**，**因为编译器会在构造和析构函数中添加额外的操作（申请/释放内存，构造/析构对象等），致使构造函数/析构函数并不像看上去的那么精简**。其次， class中的函数默认是inline型的，编译器也只是有选择性的inline，将构造函数和析构函数声明为内联函数是没有什么意义的。

- **将虚函数声明为inline，要分情况讨论**
   - **如果虚函数在编译器就能够决定将要调用哪个函数时，就能够内联**，那么什么情况下编译器可以确定要调用哪个函数呢，答案是**当用对象调用虚函数（此时不具有多态性）时，就内联展开**

**综上，当是指向派生类的指针（多态性）调用声明为inline的虚函数时**，**不会内联展开**；**当是对象本身调用虚函数时，会内联展开，当然前提依然是函数并不复杂的情况下**

### 7、C++模板是什么，底层是如何实现的？

- **编译器并不是把函数模板当成能够处理任意类的函数**；编译器从函数模板通过具体类型产生不同的函数；编译器会对函数模板进行两次编译：
- 这是因为**函数模板要被实例化后才能成为真正的函数**，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误

### 8、构造函数的作用，如何起作用？

- 构造函数只是起初始化值的作用，但实例化一个对象的时候，可以通过实例去传递参数，从主函数传递到其他的函数里面，这样就使其他的函数里面有值了。

**规则，只要你一实例化对象，系统自动会调用一个构造函数就是你不写，编译器也自动调用一次**

- 析构函数与构造函数的作用相反，**用于撤销对象的一些特殊任务处理，可以是释放对象分配的内存空间**；特点：析构函数与构造函数同名，但该函数前面加**~**

析构函数没有参数，也没有返回值，而且不能重载，**在一个类中只能有一个析构函数**。 当撤销对象时，编译器也会自动调用析构函数
每一个类必须有一个析构函数，用户可以自定义析构函数，也可以是编译器自动生成默认的析构函数。一般析构函数定义为类的公有成员

### 9、构造函数和析构函数可以调用虚函数吗，为什么

- 在C++中，不提倡在构造函数和析构函数中调用虚函数。**可以调用，但是没有意义**
- 构造函数和析构函数调用虚函数时都不使用动态联编，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数**自身类定义的虚函数版本**
- 因为父类对象会在子类之前进行构造，**此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而父类构造函数调用虚函数调用的是自身定义的虚函数，而不是子类重写的虚函数，也就是C++不会进行动态联编**
- 析构函数是**用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数**。所以在**调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义**

### 10、构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了 啥？

1. **构造函数顺序**
- 基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序
- 成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序
- 派生类自身构造函数
2. **析构函数顺序**
- 调用派生类的析构函数；
- 调用成员类对象的析构函数
- 调用基类的析构函数

构造函数：调用基类的析构函数     析构函数：顺序相反

### 11、构造函数析构函数可否抛出异常

- **构造函数**
   - 对象只有在其构造函数执行完毕才算是完全构造妥当。在构造函数中发生异常，控制权转出构造函数之外，因此，**在对象的构造函数中发生异常，对象的析构函数不会被调用。因此会造成内存泄漏**
   - **用auto_ptr对象来取代指针类成员，便对构造函数做了强化，免除了抛出异常时发生资源泄漏的危机**，不再需要在析构函数中手动释放资源
- **析构函数**
   - 如果控制权基于异常的因素离开析构函数，而此时正有另一个异常处于作用状态，C++会调用terminate函数让程序结束
   - **如果异常从析构函数抛出，而且没有在当地进行捕捉，那个析构函数便是执行不全的**。如果析构函

数执行不全，就是没有完成他应该执行的每一件事情

### 12、类什么时候会析构

- **对象生命周期结束，被销毁时**；
- **delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类析构函数是虚函数时**；
-  **对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用**

### 13、构造函数的几种关键字

- default

default关键字可以**显式要求编译器生成合成构造函数，防止在调用时相关构造函数类型没有定义而报错**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678864732108-eb6eac5e-e155-4527-998c-c7c32bdb8246.png#averageHue=%23c6eccb&clientId=u92e4ea24-5567-4&from=paste&height=654&id=u23ec528b&originHeight=839&originWidth=860&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=72103&status=done&style=none&taskId=u86c5c22a-c51a-4556-93d4-ec3f52490ed&title=&width=670.328125)

- **delete**

delete关键字可以删除构造函数、赋值运算符函数等，这样在使用的时候会得到友善的提示
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678864836562-aa403ae8-f3b7-4665-9e39-bc5238a69e91.png#averageHue=%23c6eccb&clientId=u92e4ea24-5567-4&from=paste&height=388&id=uf68441be&originHeight=471&originWidth=789&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=34662&status=done&style=none&taskId=u9519c93f-eb87-4d87-8d8c-ca55ca6f9d8&title=&width=650)
在执行语句1时，**会提示new方法已经被删除**，如果将new设置为私有方法，则会报惨不忍睹的错误，因此使用delete关键字可以更加人性化的删除一些默认方法

- 0

将虚函数定义为纯虚函数（纯虚函数无需定义，= 0只能出现在类内部虚函数的声明语句处；当然，也可以为纯虚函数提供定义，函数体可以定义在类的外部也可以定义在内部。

### 14、构造函数、拷贝构造函数和赋值操作符的区别

- **构造函数**

对象不存在，没用别的对象初始化，在创建一个新的对象时调用构造函数

- **拷贝构造函数**

对象不存在，但是使用别的已经存在的对象来进行初始化

- **赋值运算符**

对象存在，用别的对象给它赋值，这属于重载“=”号运算符的范畴，“=”号两侧的对象都是已存在的

- 拷贝构造函数和赋值运算符重载的区别
   - 拷贝构造函数是函数，赋值运算符是运算符重载
   - 拷贝构造函数会生成新的类对象，赋值运算符不能
   - 拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉
   - 形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数），但并不是所有出现"="的地方都是使用赋值运算符

举个例子：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678865166048-80bdac07-9d3c-4be0-9838-d736d80de01e.png#averageHue=%23c6eccb&clientId=u92e4ea24-5567-4&from=paste&height=827&id=u76b327f5&originHeight=821&originWidth=771&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=67069&status=done&style=none&taskId=ucb4fb0f0-1663-494b-8a77-736b29c08f8&title=&width=777)

### 15、什么是虚拟继承？
由于C++支持多继承，除了public、protected和private三种继承方式外，还支持虚拟（virtual）继承，举个例子
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678865529978-cdb8f08f-5306-4814-8cb1-70e337eecc5c.png#averageHue=%23c6eccb&clientId=u92e4ea24-5567-4&from=paste&height=337&id=u1c17c9ff&originHeight=391&originWidth=830&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=57813&status=done&style=none&taskId=u7502c5b7-f081-40b4-837a-540945b9fed&title=&width=715.328125)
上述代码所体现的关系是，**B和C虚拟继承A，D又公有继承B和C**，这种方式是**一种菱形继承或者钻石继承**，可以用如下图来表示
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678865753462-6e25d564-6b71-4841-83d5-985948d1f5fe.png#averageHue=%23c3a783&clientId=u92e4ea24-5567-4&from=paste&height=556&id=u2ca96238&originHeight=714&originWidth=882&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=54923&status=done&style=none&taskId=u57ba4ffb-48e9-40a1-9be9-0fc99712404&title=&width=687)
**虚拟继承的情况下，无论基类被继承多少次，只会存在一个实体**。虚拟继承基类的子类中，子类会增加某种形式的指针，或者指向虚基类子对象，或者指向一个相关的表格；表格中存放的不是虚基类子对象的地址，就是其偏移量，此类指针被称为bptr，如上图所示。如果既存在vptr又存在bptr，某些编译器会将其优化，合并为一个指针

### 16、什么情况会自动生成默认构造函数？
**默认构造函数：**什么情况会自动生成默认构造函数？

- 带有默认构造函数的类成员对象，如果一个类没有任何构造函数，但它含有一个成员对象，而后者有默认构造函数，那么编译器就为该类合成出一个默认构造函数。**不过这个合成操作只有在构造函数真正被需要的时候才会发生。**如果一个类A含有多个成员类对象的话，那么类A的每一个构造函数必须调用每一个成员对象的默认构造函数而且必须按照类对象在类A中的声明顺序进行
- **带有默认构造函数的基类**，如果**一个没有任何构造函数的派生类派生自一个带有默认构造函数基类**，**那么该派生类会合成一个构造函数调用上一层基类的默认构造函数**
- 带有一个虚函数的类
- 带有一个虚基类的类
- 合成的默认构造函数中，只有基类子对象和成员类对象会被初始化。所有其他的非静态数据成员都不会被初始化

### 17、抽象基类为什么不能创建对象？
**抽象类是一种特殊的类，它是为了抽象和设计的目的而建立的，它处于继承层次结构的较上层**

1. 抽象类的定义：

**称带有纯虚函数的类为抽象类**。

2. 抽象类的作用：

抽象类的主要作用是**将有关的操作作为结果接口组织在一个继承层次结构中**，由**它来为派生类提供一个公共的根**，派生类将具体实现在其基类中作为接口的操作。所以**派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类**

3. **抽象类只能作为基类来使用**，其**纯虚函数的实现由派生类给出**。**如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类**。**如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类**
4. 纯虚函数定义

 纯虚函数是一种特殊的虚函数，它的一般格式如下：
**class <类名>  {  virtual <类型><函数名>(<参数表>)=0;  …  }**
在许多情况下，**在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数**，**它的实现留给该基类的派生类去做。这就是纯虚函数的作用**
纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。**凡是含有纯虚函数的类叫做抽象类。这种类不能声明对象，只是作为基类为派生类服务**。除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象

5. 纯虚函数引入原因
- 为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。
- 在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔 雀等子类，但动物本身生成对象明显不合常理。
6. 相似概念
- **多态性**

指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态

   - 编译时多态性：通过重载函数实现
   - 运行时多态性：通过虚函数实现
- **虚函数**

虚函数是在基类中被声明为virtual，并在派生类中重新定义的成员函数，可实现成员函数的动态重载

- **抽象类**

包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象

### 18、模板类和模板函数的区别是什么？
函数模板的实例化是**由编译程序在处理函数调用时自动完成的**，而类模板的**实例化必须由程序员在程序中显式地指定**
即**函数模板允许隐式调用和显式调用而类模板只能显示调用**。在使用时类模板必须加，而函数模板不必

### 19、多继承的优缺点，作为一个开发者怎么看待多继承

- C++允许为一个派生类指定多个基类，这样的继承结构被称做多重继承
- 优点：多重继承的优点很明显，就是对象可以调用多个基类中的接口；
- 缺点：如果派生类所继承的多个基类有相同的基类，而派生类对象需要调用这个祖先类的接口方法，就会容易出现二义性

### 20、模板和实现可不可以不写在一个文件里面？为什么？

- 为什么要写在一个文件

因为在**编译时模板类的实现并不能生成真正的二进制代码**，而是**在编译调用模板类或函数的CPP文件时才会去找对应的模板声明和实现**，如果模板声明和实现不在一个文件里，**编译器只能找到模板类或函数的声明而找不到实现，而只好创建一个符号寄希望于链接程序找地址。**但**模板类或函数的实现并不能被编译成二进制代码，结果链接程序找不到地址只好报错了**
C++编程思想》第15章(第300页)说明了原因：模板定义很特殊。由template<…>处理的任何东西都意味着编译器在当时不为它分配存储空间。它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。**所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义**

### 21、将字符串“hello world”从开始到打印到屏幕上的全过程?

- 用户告诉操作系统执行HelloWorld程序（通过键盘输入等）
- 操作系统：找到helloworld程序的相关信息，检查其类型是否是可执行文件；并通过程序首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址
- 操作系统：创建一个新进程，将HelloWorld可执行文件映射到该进程结构，表示由该进程执行helloworld程序
- 操作系统：为helloworld程序设置cpu上下文环境，并跳到程序开始处
- 执行helloworld程序的第一条指令，发生缺页异常
- 操作系统：分配一页物理内存，并将代码从磁盘读入内存，然后继续执行helloworld程序
- helloword程序执行puts函数（系统调用），在显示器上写一字符串
- 操作系统：找到要将字符串送往的显示设备，通常设备是由一个进程控制的，所以，操作系统将要写的字符串送给该进程
- 操作系统：控制设备的进程告诉设备的窗口系统，它要显示该字符串，窗口系统确定这是一个合法的操作，然后将字符串转换成像素，将像素写入设备的存储映像区
- 视频硬件将像素转换成显示器可接收和一组控制数据信号
- 显示器解释信号，激发液晶屏
- OK，我们在屏幕上看到了HelloWorld

### 22、静态函数能定义为虚函数吗？常函数呢？说说你的理解

- **static成员不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义的**
- 静态与非静态成员函数之间有一个主要的区别，那就是静态成员函数没有this指针

**虚函数依靠vptr和vtable来处理**。**vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，因为它是类的一个成员**，并且**vptr指向保存虚函数地址的vtable**.对于
这就是为何static函数不能为virtual，**虚函数的调用关系：this -> vptr -> vtable ->virtual function。**

### 23、虚函数的代价？

- 带有虚函数的类，每一个类会产生一个虚函数表，**虚函数表存放在常量区，**用来存储指向虚成员函数的指针，增大类占用的空间；
- 带有虚函数的类的每一个对象，都会有有一个指向虚表的指针，会增加对象的空间大小
- **不能再是内联的函数，因为内联函数在编译阶段进行替代**，而虚函数表示等待，在运行阶段才能确定到低是采用哪种函数，虚函数不能是内联函数

### 24、说一说你了解的移动构造函数

- 有时候我们会遇到这样一种情况，我们用对象a初始化对象b后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷
- 移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”，而移动构造函数就可以将临时对象拥有的内存资源转移给当前对象。
- 拷贝构造函数中，对于指针，我们一定要采用深层复制，而**移动构造函数中，对于指针，我们采用浅层复制**

举例：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678867872821-97feb405-5a14-436c-88c8-aae6673f438c.png#averageHue=%23c6eccb&clientId=u92e4ea24-5567-4&from=paste&height=372&id=u755a264e&originHeight=331&originWidth=512&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=20933&status=done&style=none&taskId=u4eb8eda4-e2e6-41d5-9fbc-317f4b6d263&title=&width=575.328125)

### 25、什么时候需要合成拷贝构造函数？
**有三种情况会以一个对象的内容作为另一个对象的初值**

- 对一个对象做显示的初始化操作，X xx = x;
- 当对象被当做参数交给某个函数时
- 当函数传回一个类对象时

**什么时候合成拷贝构造函数：**

- 如果一个类没有拷贝构造函数，**但是含有一个类类型的成员变量，该类型含有拷贝构造函数**，此时编译器会为该类合成一个拷贝构造函数
- 如果一个类没有拷贝构造函数，**但是该类继承自含有拷贝构造函数的基类，此时编译器会为该类合成一个拷贝构造函数**
- 如果一个类没有拷贝构造函数，**但是该类声明或继承了虚函数**，此时编译器会为该类合成一个拷贝构造函数
- 如果一个类没有拷贝构造函数，**但是该类含有虚基类**，此时编译器会为该类合成一个拷贝构造函数

### 26、构造函数内部的执行顺序是什么？

- 在派生类构造函数中，所有的虚基类及上一层基类的构造函数调用；
- 对象的vptr被初始化
- 如果有成员初始化列表，将在构造函数体内扩展开来，这必须在vptr被设定之后才做
- 执行程序员所提供的代码

### 27、一个类中的全部构造函数的扩展过程是什么？

- 记录在成员初始化列表中的数据成员初始化操作会被放在构造函数的函数体内，并与成员的声明顺序为顺序
- 如果一个成员并没有出现在成员初始化列表中，但它有一个默认构造函数，那么默认构造函数必须被调用
- 如果class有虚表，那么它必须被设定初值
- 所有上一层的基类构造函数必须被调用
- 所有虚基类的构造函数必须被调用

  ​    
### 28、哪些函数不能是虚函数？把你知道的都说一说

- 构造函数，**虚函数对应一个vtable(虚函数表)，类中存储一个vptr指向这个vtable**。**如果构造函数是虚函数，就需要通过vtable调用，可是对象没有初始化就没有vptr，无法找到vtable，所以构造函数不能是虚函数**
- 内联函数，**内联函数表示在编译阶段进行函数体的替换操作**，而虚函数意味着在运行期间进行类型确定，所以内联函数不能是虚函数
- 静态函数，静态函数不属于对象属于类，**静态成员函数没有this指针**，因此静态函数设置为虚函数没有任何意义
- 友元函数，友元函数不属于类的成员函数，不能被继承。**对于没有继承特性的函数没有虚函数的说法**
- 普通函数，普通函数不属于类的成员函数，**不具有继承特性，因此普通函数没有虚函数**

### 29、什么是纯虚函数，与虚函数的区别
虚函数和纯虚函数的区别？

- 虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，而只含有虚函数的类不能被称为抽象类
- 虚函数可以被直接调用，也可以被子类重载以后，以多态的形式调用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类有声明而没有定义
- 定义形式不同。虚函数的定义形式：virtual{};纯虚函数的定义形式：virtual  { } = 0
- 在虚函数表中值不同，既然都是虚函数，它的函数指针会被存在虚函数表中，由于**纯虚函数并没有具体的函数体，因此它在虚函数表中的值就为0**，而具有函数体的虚函数则是函数的具体地址

**一个类中如果有纯虚函数的话，称其为抽象类**。**抽象类不能用于实例化对象，否则会报错**。抽象类一般用于定义一些公有的方法。子类继承抽象类也必须实现其中的纯虚函数才能实例化对象
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1678868625076-2fd49cf7-b35e-4b18-a8e4-868f8713319d.png#averageHue=%23c6eccb&clientId=u92e4ea24-5567-4&from=paste&height=761&id=ud2c6e03a&originHeight=715&originWidth=657&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=52250&status=done&style=none&taskId=u0f275ec1-348d-4180-93e7-a568410d3fd&title=&width=699)


# 操作系统

## 操作系统
### 1、进程、线程和协程的区别和联系
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1676958266189-a4cb124d-8bd2-4a52-bce6-9b9a3496a2c3.png#averageHue=%23c5ebca&clientId=u513db796-d74f-4&from=paste&height=699&id=u432f940a&originHeight=1048&originWidth=960&originalType=binary&ratio=1&rotation=0&showTitle=false&size=197596&status=done&style=none&taskId=uaab8f2b2-0833-44d0-8610-726c48c90ab&title=&width=640)
**区别：**

- **根本区别：**进程是资源调度的基本单位，线程是程序执行的基本单位
- 资源开销：每个进程都有独立的代码和数据空间，进程之间切换会有较大的开销，比如要切换虚拟空间地址，切换内核栈和硬件上下文等。而线程切换时只需要保存和设置程序计数器和少量寄存器内容，因此开销很小
- 内存分配：同一进程的不同线程共享本进程的地址空间和资源，独自拥有各自的栈，而进程之间的地址空间和资源是相互独立的
- 健壮性：一个进程崩溃后，一般不会对其他进程产生影响。但一个线程崩溃整个进程都会死掉。所以多进程要比多线程健壮
1. 进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可

执行程序

2. 线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主

线程和进程是相互依存的关系，主线程结束进程也会结束。多提一句：协程是用户态的轻量级线程，线
程内部调度的基本单位
### 2、线程与进程的比较

1. 线程启动速度快，轻量级
2. 线程的系统开销小
3. 线程使用有一定难度，需要处理数据一致性问题
4. 不同线程共享的有堆、全局变量、静态变量、指针，引用、文件等，而独自占有栈
### 3、一个进程可以创建多少线程，和什么有关？
理论上，一个进程可用虚拟空间是2G，默认情况下，线程的栈的大小是1MB，所以理论上最多只能创建
2048个线程。如果要创建多于2048的话，必须修改编译器的设置。
因此，一个进程可以创建的线程数由可用虚拟空间和线程的栈的大小共同决定，只要虚拟空间足够，那
么新线程的建立就会成功。如果需要创建超过2K以上的线程，减小你线程栈的大小就可以实现了，虽然
在一般情况下，你不需要那么多的线程。过多的线程将会导致大量的时间浪费在线程切换上，给程序运
行效率带来负面影响。
### 4、外中断和异常有什么区别？
外中断是指由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处
理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。
而异常时由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。

- 相同点：
   - 最后都是由CPU发送给内核，由内核去处理
   - 处理程序的流程设计上是相似的
- 不同点：
   - 产生源不相同，异常是由CPU产生的，而中断是由硬件设备产生的
   - 内核需要根据是异常还是中断调用不同的处理程序
   - 中断不是时钟同步的，这意味着中断可能随时到来；异常由于是CPU产生的，所以它是时钟同步的
   - 当处理中断时，处于中断上下文中；处理异常时，处于进程上下文中
### 5、进程线程模型你知道多少？
对于进程和线程的理解和把握可以说基本奠定了对系统的认知和把控能力。其核心意义绝不仅仅是“线
程是调度/执行的基本单位，进程是资源分配的基本单位”这么简单。

### 6、同步与互斥
互斥是一种特殊的同步
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1681654731958-6da6317f-edef-413f-850e-55183c38ded8.png#averageHue=%23faf9f7&clientId=u904f668e-2dae-4&from=paste&height=276&id=ufe423201&originHeight=310&originWidth=983&originalType=binary&ratio=1&rotation=0&showTitle=false&size=50563&status=done&style=none&taskId=u64cd4345-a854-4e34-9f22-2c33d72d589&title=&width=875.328125)
### 7、Linux下同步机制

- 信号量：可用于进程同步，也可用于线程同步
- 互斥锁+条件变量：只能用于线程同步

### 8、操作系统在对内存进行管理的时候需要做些什么

- 负责内存空间的分配与回收
- 需要提供某种技术从逻辑上对物理内存进行扩充
- 需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换
- 需要提供内存保护功能，保证各进程在各自存储空间内运行，互不干扰

### 9、进程间的通信方式

- 管道：管道是一种半双工的通信方式，数据只能单向流动
   - 无名管道：无名管道只能在具有亲缘关系的进程之间使用，进程的亲缘关系通常是指父子进程
   - 命名管道：允许在没有亲缘关系的进程间使用，**命名管道是FIFO文件，存在于文件系统中，可以通过文件路径名来指出，因而可以在没有亲缘关系的进程间通信**
- 共享内存：

**共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问**。**共享内存是最快的IPC方式**，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与信号量，配合使用来实现进程间的同步和通信

- 消息队列：

消息队列是有消息的链表，包括POSIX消息对和System V消息队列。**有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息**。消息队列克服了信号承载信息量少，管道只能成该无格式字节流以及缓冲区大小受限等缺点

- 套接字：

适用于不同机器间进程通信，在本地也可作为两个进程通信的方式

- 信号：

信号是比较复杂的通信方式，**用于通知接收进程有某种事情发生**，除了用于进程间通信外，进程还可以发送信号给进程本身，比如按下ctrl + C就是信号

- 信号量：

信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问
### 

### 10、线程间的通信方式
Linux：

- 信号：类似进程间的信号处理
- 锁机制：互斥锁、读写锁和自旋锁
- 条件变量：使用通知的方式解锁，与互斥锁配合使用

一般来说**条件变量被用于线程间的同步，**条件变量是用来等待线程而不是上锁的，条件变量通常和[互斥锁](https://so.csdn.net/so/search?q=%E4%BA%92%E6%96%A5%E9%94%81&spm=1001.2101.3001.7020)一起使用。条件变量之所以要和互斥锁一起使用，主要是因为互斥锁的一个明显的特点就是它只有两种状态：锁定和非锁定，而条件变量可以通过允许线程阻塞和等待另一个线程发送信号来弥补互斥锁的不足，**所以互斥锁和条件变量通常一起使用**

- 信号量：包括无名线程信号量和命名线程信号量
### 11、虚拟内存的目的是什么

- **虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存**
- 为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页，**这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中**。当程序引用到不在物理内存中的页时，**由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令**
- 从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说**一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能**

### 12、介绍一下几种典型的锁

- 读写锁
   - 多个读者可以同时进行读
   - 写者必须互斥（只允许一个写者写，也不能读者写者同时进行）
   - 写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）
- 互斥锁

一次只能一个线程拥有互斥锁，其他线程只有等待
互斥锁是在**抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒**，而操作系统负责线程调度，为了实现**锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。（上下文切换其实就是需要从用户态切换到内核态）**

- 条件变量
   - 互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件
   - 当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程
   - 总的来说**互斥锁是线程间互斥的机制**，**条件变量则是同步机制**。
- 自旋锁

如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。如果别的线程长时期占有锁，那么自旋就是在浪费CPU做无用功，**所以自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高**

### 13、怎么回收子线程？有哪些方法？

- **等待线程结束**：int pthread_join(pthread_t tid, void** retval)

主线程调用，等待子线程退出并回收其资源，类似于进程中wait/waitpid回收僵尸进程，调用pthread_join的线程会被阻塞

   - tid：创建线程时通过指针得到tid值
   - retval：指向返回值的指针
- **结束线程**：pthread_exit(void *retval);

子线程执行，用来结束当前线程并通过retval传递返回值，该返回值可通过pthread_join获得

   - retval：同上
- **分离线程**：int pthread_detach(pthread_t tid);

主线程、子线程均可调用。主线程中pthread_detach(tid)，子线程中pthread_detach(pthread_self())，调用后和主线程分离，子线程结束时自己立即回收资源

### 14、内存覆盖是什么？有什么特点？

- 概念：

由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可以把用户空间分成为一个固定区和若干个覆盖区。
将**经常活跃的部分放在固定区**，其余部分按照调用关系分段，首先将那**些即将要访问的段放入覆盖区**，其他段放在外存中，**在需要调用前，系统将其调入覆盖区**，替换覆盖区中原有的段

- 内存覆盖技术的特点：

打破了必须将一个进程的全部信息装入内存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行

### 15、内存交换是什么？有什么特点？

- 概念：

内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)

   - 换入：把准备好竞争CPU运行的程序从辅存移到内存
   - 把处于等待状态（或CPU调度原则下被剥夺运行权力）的程序从内存移到辅存，把内存空间腾出来
- 什么时候会进行内存交换？

内存交换通常在许多进程运行且内存吃紧时发生，而系统负荷降低就暂停。例如:在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程;如果缺页率明显下降，就可以暂停换出

### 16、什么是快表，你知道多少关于快表的知识？

- **概念：**

快表，又称联想寄存器(TLB) ，是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表

- **有快表和没快表的区别**
   - CPU给出逻辑地址，由某个硬件计算出页号和页内偏移量
   - **有快表**，则先在快表中查询计算出的页号，如果找到匹配的页号，说明要访问的页表项在快表中有备份，通过页表项得到该页对应的内存块号，将内存块号与页内偏移量拼接成物理地址，访问该物理地址对应的内存。**因此，若有快表并且快表命中，访问某个逻辑地址只需要一次内存访问**
   - **没有快表或快表未命中。**需要先访问内存中的页表（一次访存），找到对应页表项，得到页面对应的内存块号，计算出物理地址，然后访问该物理地址对应的内存单元（二次访存）。因此，没有快表或快表未命中需要两次访问内存。(**在找到页表项后，应同时将其存入快表,以便后面可能的再次访问。但若快表已满，则必须按照-定的算法对旧的页表项进行替换**)

### 17、守护进程、僵尸进程和孤儿进程

- 守护进程

指在后台运行的，没有控制终端与之相连的进程。它独立于控制终端，周期性地执行某种任务。Linux的大多数服务器就是用守护进程的方式实现的，如web服务器进程http等

- 孤儿进程

如果父进程先退出，子进程还没退出，那么**子进程的父进程将变为init进程**。（注：任何一个进程都必须有父进程）。
一个父进程退出，而**它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程**。**孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作**

- 僵尸进程
   - 如果子进程先退出，父进程还没退出，那么**子进程必须等到父进程捕获到了子进程的退出状态才真正结束**，否则这个时候**子进程就成为僵尸进程**。
   - 设置**僵尸进程的目的是维护子进程的信息**，以便父进程在以后某个时候获取。这些信息至少包括进程ID，进程的终止状态，以及该进程使用的CPU时间，所以当终止子进程的父进程调用wait或waitpid时就可以得到这些信息
   - 如果一个进程终止，而该进程有子进程处于僵尸状态，那么它的**所有僵尸子进程的父进程ID将被重置为1（init进程）**。继承这些**子进程的init进程将清理它们**（也就是说init进程将wait它们，从而去除它们的僵尸状态）

### 18、如何避免僵尸进程

- 通过signal(SIGCHLD, SIG_IGN)通知**内核对子进程的结束不关心，由内核回收。**如果不想让父进程挂起，可以在**父进程中加入一条语句：signal(SIGCHLD,SIG_IGN);**表示父进程忽略SIGCHLD信号，该信号是子进程退出的时候向父进程发送的
- 如果父进程很忙可以**用signal注册信号处理函数，在信号处理函数调用wait/waitpid等待子进程退出**

第一种方法忽略SIGCHLD信号，这**常用于并发服务器的性能的一个技巧因为并发服务器常常fork很多子进程**，子进程终结之后需要服务器进程去wait清理资源。如果将此信号的处理方式设为忽略，可让**内核把僵尸子进程转交给init进程去处理，省去了大量僵尸进程占用系统资源**

### 19、局部性原理你知道吗？主要有哪两大局部性原理？各自是什么？
主要分为时间局部性和空间局部性

- **时间局部性**:如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)
- **空间局部性**:一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的)

### 20、父进程、子进程、进程组、作业和会话

- 父进程

已创建一个或多个子进程的进程

- 子进程
   - 由**fork创建的新进程被称为子进程（child process）**。该函数被调用一次，但返回两次。**两次返回的区别是子进程的返回值是0，而父进程的返回值则是新进程（子进程）的进程 id**。将子进程id返回给父进程的理由是：因为一个进程的子进程可以多于一个，**没有一个函数使一个进程可以获得其所有子进程的进程id**。对子进程来说，之所以fork返回0给它，是因为它随时可以**调用getpid()来获取自己的pid**；也可以调用getppid()来获取父进程的id
   - fork之后，操作系统会复制一个与父进程完全相同的子进程。父子进程共享代码空间，但是数据空间是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置。
   - **子进程从父进程继承的有：**进程的资格、环境、堆栈、内存、进程组号
   - **子进程独有的有：**进程号、资源使用设定为0，不同的父进程号（父子进程各自的父进程号不同）
- 进程组：

进程组就是多个进程的集合，其中肯定有一个组长，其进程PID等于进程组的PGID。只要在某个进程组中一个进程存在，该进程组就存在，这与其组长进程是否终止无关。

- 作业

shell分前后台来控制的不是进程而是作业（job）或者进程组（Process Group）。**一个前台作业可以由多个进程组成，一个后台也可以由多个进程组成**，shell**可以运行一个前台作业和任意多个后台作业，这称为作业控制**

   - **为什么只能运行一个前台作业？ **

            当我们在前台新起了一个作业，shell就被提到了后台，因此shell就没有办法再继续接受我们的指令并且解析运行了。 但是如果前台进程退出了，shell就会有被提到前台来，就可以继续接受我们的命令并且解析运行

- 会话：

会话（Session）是一个或多个进程组的集合。一个会话可以有一个控制终端。在xshell或者WinSCP中打开一个窗口就是新建一个会话

### 21、程序从堆中动态分配内存时，虚拟内存上怎么操作的

- 页表：是一个存放在物理内存中的数据结构，它记录了虚拟页与物理页的映射关系
- 在进行动态内存分配时，例如**malloc()函数或者其他高级语言中的new关键字**，操作系统会在**硬盘中创建或申请一段虚拟内存空间**，并更新到页表（**分配一个页表项（PTE），使该PTE指向硬盘上这个新创建的虚拟页**），通过PTE建立虚拟页和物理页的映射关系

虚拟内存是创建在硬盘上的，每个进程都有自己独属的虚拟内存空间，而这虚拟内存空间的真实位置就是在硬盘上，当该进程需要运行是，会通过页面置换算法将其虚拟内存映射到内存上，从而运行

### 22、磁盘调度算法有哪些？
**概念**：磁盘调度算法的目的很简单，就是为**了提高磁盘的访问性能**，一般是通**过优化磁盘的访问顺序来做到的**。
寻道的时间是磁盘访问最耗时的部分，如果请求顺序优化得当，必然可以节省一些不必要的寻道时间，从而提高磁盘的访问性能。

读写一个磁盘块的时间的影响因素是什么：

- 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）
- 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）
- 实际的数据传输时间

其中，**寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短**

- 先来先服务

**按照磁盘请求的顺序进行调度。**
优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长

- 最短寻道时间优先

**优先调度与当前磁头所在磁道距离最近的磁道**
虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。

- 电梯扫描算法

电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题

### 23、抖动你知道是什么吗？它也叫颠簸现象

- 概念

刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸

- 原因：

产生抖动的**主要原因是进程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够)**
为**进程分配的物理块太少，会使进程发生抖动现象**。为进程分配的**物理块太多，又会降低系统整体的并发度，降低某些资源的利用率**

### 24、原子操作是如何实现的？
**原子操作**（**atomic operation**），指不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会切换到其他线程
处理器使用**基于对缓存加锁或总线加锁的方式**来实现多处理器之间的原子操作。

- 首先处理器会**自动保证基本的内存操作的原子性**。处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址
- 但是**复杂的内存操作处理器是不能自动保证其原子性的**，比如跨总线宽度、跨多个缓存行和跨页表的访问。但是，处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性

### 25、内存交换你知道有哪些需要注意的关键点吗？

- **交换需要备份存储，通常是快速磁盘**，它必须足够大，并且提供对这些内存映像的直接访问
- 为了有效使用CPU，需要**每个进程的执行时间比交换时间长**，而影响交换时间的主要是转移时间，转移时间与所交换的空间内存成正比
- 如果换出进程，比如确保该进程的内存空间成正比。
- 交换通常在有许多进程运行且内存空间吃紧时开始启动，而系统负荷降低就暂停。

### 26、系统并发和并行

- 并发是指宏观上在**一段时间内能同时运行多个程序**，而并行则指**同一时刻能运行多个指令**
- 并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。
- 操作系统通过引入进程和线程，使得程序能够并发运行。

### 27、页面置换算法

- 最佳置换算法（OPT）

优先淘汰xx最长时间内不会被访问的页面。**优缺点：**缺页率最小，性能最好;但无法实现

- 先进先出置换算法（FIFO）

优先淘汰最先进入内存的页面。**优  点：**实现简单;但性能很差，可能出现Belady异常

- 最近最久未使用置换算法（LRU）

优先淘汰最近最久没访问的页面。**优缺点**：性能很好;但需要硬件支持，算法开销大

- 时钟置换算法（NRU）

循环扫描各页面 第一轮淘汰访问位=0的，访问位为1的则改为0。若第1轮没选中，则进行第二轮扫描，找到第一个访问为为0的页面置换。
**优缺点**：实现简单，算法开销小;但未考虑页面是否被修改过

- 改进时钟置换算法（改进NRU）
### 28、死锁
死锁是指两个或多个线程互相等待对方数据的过程，死锁的产生会导致程序卡死，不解锁程序将永远无法进行下去。

1. 死锁产生原因：

两个线程A和B，两个数据1和2。线程A在执行过程中，首先对资源1加锁，然后再去给资源2加锁，但是由于线程的切换，导致线程A没能给资源2加锁。线程切换到B后，线程B先对资源2加锁，然后再去给资源1加锁，由于资源1已经被线程A加锁，因此线程B无法加锁成功，当线程切换为A时，A也无法成功对资源2加锁，由此就造成了线程AB双方相互对一个已加锁资源的等待，死锁产生
死锁产生有以下**四个必要条件：**

- 互斥条件：进程对所需求的资源具有排他性，若有其他进程请求该资源，请求线程只能等待
- 不可剥夺条件：进程所获得的资源未释放前，不能被其他线程强行夺走，只能自己释放
- 请求和保持条件：进程当前所拥有的资源在进程请求其他资源是，仍由该进程所占有
- 循环等待条件：存在一种进程资源循环等待链，链中每一进程已获得的资源都被链中下一进程所请求
2. **死锁的解决方案：**保证上锁的顺序一致
3. 死锁的处理方法：

主要有以下四种方法：

- 鸵鸟策略：忽略死锁的问题，不理他
- 死锁检测与死锁恢复
- 死锁预防

在程序运行之前预防死锁，破坏四个死锁产生必要条件中的任意一个

- 死锁避免

### 29、内部碎片与外部碎片

- 内部碎片：分配给某些进程的内存区域有些部分没用上，常见于**固定分配方式**。

也就是比如分给一个进程50M的内存，但该进程运行只需要45M，多出来这5M就是内部碎片，简单来说就是内部碎片是已经分配出去的内存，但是没用到

- 外部碎片：内存中某些**空闲区因为比较小**，而难以利用上，一般出现在内存动态分配方式中。

外部碎片就是内存中**一些还未分配出去的内存块**，但是由于太小，无法直接分配给某个进程，这就是外部碎片
### 30、为什么分段式存储管理有外部碎片而无内部碎片？为什么固定分区分 配有内部碎片而不会有外部碎片？
**分段式分配是按需分配，而固定式分配是固定分配的方式**

- **固定分配：**

将100M分割成10块，每块10M，一个程序需要45M，那么需要分配5块，第五块只用了5M，剩下的5M就是内部碎片
分段式分配，按需分配，一**个程序需要45M，就给分片45MB**，剩下的55M供其它程序使用，**不存在内部碎片**

- **分段式分配：**

100M，比如，内存分配依次5M，15M，50M，25M，程序运行一段时间之后，5M，15M的程序运行完毕，释放内存，其他程序还在运行，再次分配一个10M的内存供其它程序使用，只能从头开始分片，**这样，就会存在10M+5M的外部碎片**

### 31、多进程和多线程的区别是什么？换句话说，什么时候该用多线程，什么时候该用多进程？

- 频繁修改：需要频繁创建和销毁的优先使用多线程。所谓大量计算，当然就是要消耗很多cpu，切换频繁了，这种情况先线程是最合适的
- 计算量：需要大量计算的优先使用多线程  因为需要消耗大量CPU资源且切换频繁，所以多线程好一点。所谓大量计算，当然就是要消耗很多cpu，切换频繁了，这种情况先线程是最合适的
- 相关性：任务间相关性比较强的用多线程，相关性比较弱的用多进程。**因为线程之间的数据共享和同步比较简单。**
- 多分布：可能要扩展到多机分布的用多进程，多核分布的用多线程

### 32、在执行malloc申请内存时，操作系统是怎么做的
从操作系统层面上看，malloc是通过两个系统调用来实现的： brk和mmap

- brk是将进程数据段(.data)的最高地址指针向高处移动，这一步可以扩大进程在运行时的堆大小
- mmap是在进程的虚拟地址空间中寻找一块空闲的虚拟内存，这一步可以获得一块可以操作的堆内存。

通常，分配的内存小于128k时，通过brk调用来获取虚拟内存。大于128k时，使用mmap来获得虚拟内存。
进程先通**过这两个系统调用获取或者扩大进程的虚拟内存**，获得相应的虚拟地址，在访问这些虚拟地址的时候，**通过缺页中断，让内核分配相应的物理内存，这样内存分配才算完成**。

### 33、进程调度算法

- 先来先服务

先来先服务 first-come first-serverd（FCFS） 非抢占式的调度算法，按照请求的顺序进行调度

- 短作业优先 shortest job first（SJF）  

非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

- 最短剩余时间优先 shortest remaining time next（SRTN）

最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较

- 时间片轮转

将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。
**时间片轮转算法的效率和时间片的大小有很大关系：**

   - 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间
   - 而如果时间片过长，那么实时性就不能得到保证
- 优先级调度  

为每个进程分配一个优先级，按优先级进行调度。
为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级

- 多级反馈队列  

一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。
多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。
这种方式下，之前的进程只需要交换 7 次。每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。
可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。



# 计算机网络

### 1、七层网络模型

- 物理层，此时数据被称为比特流
- 数据链路层，此时数据被称为帧
- 网络层，此时数据被称为包
- 传输层，此时数据被称为段
- 会话层
- 表示出
- 应用层

总结

- 网络七层模型是一个标准，而非实现
- 网络四层模型是一个实现的应用模型
- 网络四层模型由七层模型简化合并而来

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1681795593945-e4a278a5-6a0c-4fc6-8dc5-91c4c87a90db.png#averageHue=%23e7debc&clientId=u33e0e403-54ac-4&from=paste&height=562&id=u3c324f13&originHeight=843&originWidth=1414&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=262425&status=done&style=none&taskId=ufb5363cb-df67-4ec8-8128-fccc076a60e&title=&width=942.6666666666666)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1681795617686-ca014af3-24ae-463a-8739-8e130c3e20b0.png#averageHue=%23f4dfb7&clientId=u33e0e403-54ac-4&from=paste&height=526&id=uf7380185&originHeight=789&originWidth=1389&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=274457&status=done&style=none&taskId=u7bac301e-d2d5-44cc-89ca-070ca09a816&title=&width=926)

### 2、说一下一次完整的HTTP请求过程包括哪些内容

- 根据域名，进行DNS域名解析；
- 拿到解析的IP地址，客户端和服务端建立TCP连接
- 向IP地址，也就是服务器端发送HTTP请求；
- 服务器处理请求并返回响应结果；
- 关闭TCP连接；
- 浏览器解析响应结果，布局渲染后显示；

### 3、DNS协议
概念：DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串
**通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析**），**通俗的讲**，**我们更习惯于记住一个网站的名字**，比如www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2
DNS协议负责将主机域名转换为IP地址，使用UDP传输，属于应用层协议

### 4、DNS具体解析过程

- http请求发起，浏览器会先在本地找之前有没有缓存过的域名所对应的ip地址，有的话会跳过dns解析
- 找硬盘hosts文件，有的话直接找到hosts文件中的ip(hosts文件是没有扩展名的系统文件，主要作用是加快域名解析)
- 本地的hosts文件没有得带对应的ip地址，浏览器会发送dns请求到本地dns服务器，本地DNS服务器会**首先查询它的缓存记录**，如果缓存中有此条记录，就可以直接返回结果，此过程**是递归的方式进行查询**
- 本地dns服务器向**dns根服务器**进行查询，dns会返回给本地dns服务器一个**域名服务器地址**
- 本地dns服务器继续向**域服务器**发起请求，域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的**域名的解析服务器的地址**
- 最后，本地DNS服务器向**域名的解析服务器发出请求**，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问

**DNS查询方式：**
当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式，递归解析和迭代解析。

- **递归解析**

局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端

- **迭代解析**

局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。**也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查**
### 5、TCP拆包和粘包是什么，发生的原因？
**拆包：**
一个完整的业务可能会被**TCP拆分成多个包进行发送**，也有可能把多个小的包封装成一个大的数据包发送，这个就是TCP的拆包和粘包问题
**原因：**

- 应用程序写**入数据的字节大小大于套接字发送缓冲区**的大小.
- TCP传输会进行MSS大小的分段

**MSS，最大分节大小，为TCP数据包每次传输的最大数据分段大小**，一般由接收端向对端TCP通知对端在每个分节中能发送的最大TCP数据。MSS值为**MTU值减去IPv4 Header（20 Byte）和TCP header（20 Byte）得到**

- 以太网的payload大于MTU进行IP分片。（ MTU指：一种通信协议的某一层上面所能通过的最大数据包大小。）

**解决方案：**

- 消息定长
- 在包尾部增加回车或者空格符等特殊字符进行分割
- 将消息分为消息头和消息尾

**粘包：**
TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。
**原因：**

- 由TCP连接复用造成的粘包问题。
- 因为TCP默认会使用Nagle算法，此算法会导致粘包问题
- 数据包过大造成的粘包问题。
- 流量控制，拥塞控制也可能导致粘包。
- 接收方不及时接收缓冲区的包，造成多个包接收

**解决方案：**

- Nagle算法问题导致的，需要结合应用场景适当关闭该算法
- 尾部标记序列。通过特殊标识符表示数据包的边界，例如\n\r，\t，或者一些隐藏字符
- 头部标记分步接收。在TCP报文的头部加上表示数据长度
- 应用层发送数据时定长发送


### 6、GET和POST的区别

- get是获取数据，post是修改数据
- get把请求的数据放在url上， 以?分割URL和传输数据，参数之间以&相连，所以get不太安全。而post把数据放在HTTP的包体内（requrest body）
-  get提交的数据最大是2k（ 限制实际上取决于浏览器）， post理论上没有限制。
-  GET产生**一个TCP数据包**，浏览器会把**http header和data一并发送出去，服务器响应200(返回数据)**; POST产生两个TCP数据包，**浏览器先发送header，服务器响应100 continue**，**浏览器再发送data，服务器响应200 ok(返回数据)**。
-  GET请求会被浏览器主动缓存，而POST不会，除非手动设置
-  本质区别：GET是幂等的，而POST不是幂等的

**这里的幂等性：**幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果
正因为它们有这样的区别，所以**不应该且不能用get请求做数据的增删改这些有副作用的操作**。因为get请求是幂等的，在网络不好的隧道中会尝试重试。**如果用get请求增数据，会有重复操作的风险，而这种重复操作可能会导致副作用**（浏览器和操作系统并不知道你会用get请求去做增操作）

### 7、在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？

### 8、DNS负载均衡是什么策略？
**原因：**
当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉
**解决方法：**
处理办法就是用**DNS负载均衡技术**，它的原理是在DNS服务器中为**同一个主机名配置多个IP地址**（主机名也就是域名，为每个域名配置多个ip地址，也就是配置多台服务器端）在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的

### 9、HTTPS和HTTP的区别

- HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全， HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。
- https协议需要到ca申请证书
- http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443

### 10、什么是SSL/TLS

- SSL是一种用于**加密和验证**应用程序（如浏览器）和Web服务器之间发送的数据的协议。 Https的加密机制是一种**共享密钥加密和公开密钥加密并用的混合加密机制**
- SSL/TLS协议作用：**认证用户和服务，加密数据**，维护数据的完整性的应用层协议。**加密和解密需要两个不同的密钥，故被称为非对称加密**；**加密和解密都使用同一个密钥的 是对称加密**
- 对称加密：优点在于加密、解密效率通常比较高 ，HTTPS 是基于非对称加密的， 公钥是公开的

### 11、HTTPS是如何保证数据传输安全的，整体流程是什么（SSL是怎么工作保证安全的）

- 客户端向服务器端发起SSL连接请求；
- 服务器把公钥发送给客户端，并且服务器端保存着唯一的私钥
- 客户端用公钥对双方通信的对称秘钥进行加密，并发送给服务器端
- 服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密
- 进行数据传输，服务器和客户端双方用公有的相同的对称秘钥对数据进行加密解密，可以保证在数据收发过程中的安全，即使第三方获得数据包，也无法对其进行加密，解密和篡改

SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。

### 12、如何保证公钥不被篡改
将公钥放在**数字证书**中。只要证书是可信的，公钥就是可信的。

- **数字证书是什么：**

通过使用 证书 来对通信方进行认证

   - **数字证书认证机构**（CA，Certificate Authority）是**客户端与服务器双方都可信赖的第三方机构**
   - 服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起
   - **进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了**
- **数字证书如何防伪：**

数字签名、摘要是证书防伪非常关键的武器。 “摘要”就是对传输的内容，通过hash算法计算出一段固定长度的串。然后，通过发送方的私钥对这段摘要进行加密，加密后得到的结果就是“数字签名”

### 13、HTTP请求和响应报文主要有哪些字段？

- 请求报文
   - 请求行：Request Line
   - 请求头：Request Headers
   - 请求体：Request Body
- 响应报文
   - 状态行：Status Line
   - 响应头：Response Headers
   - 响应体：Response Body

### 14、Cookie和Session
**cookie和Session都是用来跟踪浏览器用户身份的会话方式。**

- Cookie
   - Cookie 是**服务器发送到用户浏览器并保存在本地的一小块数据**，它会在**浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器**。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销
   - cookie 的出现是因为 **HTTP 是无状态的一种协议**，换句话说，服务器记不住你，可能你每刷新一次网页，就要重新输入一次账号密码进行登录。这显然是让人无法接受的，**cookie 的作用就好比服务器给你贴个标签，然后你每次向服务器再发请求时，服务器就能够 通过cookie 认出你**
   - **Cookie用途：**会话状态管理、个性化设置、浏览器行为跟踪
- Session

除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。（Session还是放在Cookie中的）
**使用 Session 维护用户登录状态的过程如下：**

   - 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；
   - 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；
   - 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；
   - 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。

### 15、Session和cookie应该如何去选择（适用场景）？

- Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；
- Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；
- 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。

### 16、Cookies和Session区别是什么？
Cookie和Session都是客户端与服务器之间保持状态的解决方案

- 存储的位置不同，cookie：存放在客户端，session：存放在服务端。Session存储的数据比较安全
- 存储的数据类型不同

两者都是key-value的结构，但针对value的类型是有差异的
cookie：value只能是字符串类型，session：value是Object类型

- 存储的数据大小限制不同

cookie：大小受浏览器的限制，很多是是4K的大小， session：理论上受当前内存的限制

### 17、什么是RARP？工作原理

- ARP（地址转换协议）是只知道自己的ip地址，请求对应的mac地址（mac地址是设备的硬件地址）
- RARP，反向地址转换协议，网络层协议，RARP与ARP工作方式相反。 RARP使**只知道自己硬件地址的主机**能够知道其IP地址。RARP发出要反向解释的物理地址并希望返回其IP地址，**应答的IP地址由RARP服务器发出**

**原理：**

   - 网络上的每台设备都会有一个独一无二的硬件地址，通常是由设备厂商分配的MAC地址。主机从网卡上读取MAC地址，然后在**网络上发送一个RARP请求的广播数据包**，请求**RARP服务器回复该主机的IP地址**
   - RARP服务器收到了RARP请求数据包，**为其分配IP地址，并将RARP回应发送给主机**
   - 主机收到RARP回应后，就使用得到的IP地址进行通讯

### 18、端口有效范围是多少到多少？

- 0-1023为知名端口号，比如其中HTTP是80，FTP是20（数据端口）、21（控制端口）
- UDP和TCP报头**使用两个字节存放端口**号，所以端口号的**有效范围是从0到65535**。**动态端口的范围是从1024到65535**



### 19、MTU和MSS分别是什么？

- MTU：maximum transmission unit，**最大传输单元**，由硬件规定，如以太网的MTU为1500字节。
- MSS：maximum segment size，**最大分节大小**，为T**CP数据包每次传输的最大数据分段大小**，一般由**发送端向对端TCP通知对端在每个分节中能发送的最大TCP数据**。MSS值为MTU值减去IPv4 Header（20 Byte）和TCP header（20 Byte）得到



### 20、TCP头部有哪些信息？

- 序列号（32bit）：用于 TCP 通信过程中**某一传输方向上字节流的每个字节的编号**，为了确保数据通信的有序性，避免网络中乱序的问题
- 确认号：确认序列号是**接收确认端所期望收到的下一序列号**。确认序号应当是**上次已成功收到数据字节序号加1**，只有当标志位中的** ACK 标志为 1 时该确认序列号的字段才有效**。主要用来解决丢包的问题
- 首部长：标识首部有多少个4字节 * 首部长，最大为15，即60字节
- 标志位（6bit）
   - URG：标志紧急指针是否有效。
   - ACK：**标志确认号是否有效（确认报文段）**。用于解决丢包问题。

这个标识可以理解为发送端发送数据到接收端，发送的时候 ACK 为 0，**标识接收端还未应答**，一旦接收端接收数据之后，**就将 ACK 置为 1**，发送端接收到之后，就知道了接收端已经接收了数据。

   - PSH：提示接收端立即从缓冲读走数据。
   - RST：表示要求对方重新建立连接（复位报文段）。
   - SYN：**表示请求建立一个连接**（连接报文段）。
   - FIN：**表示关闭连接**（断开报文段）。
- 窗口（16bit）：接收窗口。用于告知对方（发送方）**本方的缓冲还能接收多少字节数据**。用于解决流控
- 校验和（16bit）：接收端用CRC检验整个报文段有无损坏

### 21、TCP和UDP是什么
TCP（Transmission Control Protocol 传输控制协议）是一种**面向连接的**、**可靠的**、基**于字节流的传输层通信协议**
UDP是一种提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）

### 22、TCP三次握手相关内容
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1681800469166-77123c16-3ac3-492e-983b-0966d1df0091.png#averageHue=%23ede3cd&clientId=u33e0e403-54ac-4&from=paste&height=695&id=uafb364b0&originHeight=1042&originWidth=1431&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=290860&status=done&style=none&taskId=ucd9e4fc3-c878-4463-9457-d2c0bb3eeb8&title=&width=954)
**概念：**
三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，**需要客户端和服务器总共发送3个包**。进行**三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常**、指定**自己的初始化序列号为后面的可靠性传送做准备**。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息
**步骤：**
刚开始**客户端处于 Closed **的状态，**服务端处于 Listen 状态**，进行三次握手：

- 第一次握手：**客户端给服务端发一个 SYN 报文**，并指明**客户端的初始化序列号** ISN(c)。此时客户端处于 **SYN_SEND **状态

首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号

- 第二次握手：服务器收到客户端的 SYN 报文之后，会以**自己的 SYN +ACK报文作为应答**，并且也是指**定了自己的初始化序列号 ISN(s)**。同时会把**客户端的 ISN + 1 作为ack确认号的值**，**ACK标志位置1，表示自己已经收到了客户端的 SYN**，此时服务器处于 **SYN_RCVD **的状态

在确认报文段中**SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y**

- 第三次握手：客户端收到 SYN 报文之后，**会发送一个 ACK 报文**，当然，也是一样把**服务器的 ISN + 1 作为 ack确认号的值，ACK标志位置1，表示已经收到了服务端的 SYN 报文**，此时客户端处于 **ESTABLISHED** 状态。**服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态**，此时，双方已建立起了连接

确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号
**什么是半连接队列：**

- 服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为**半连接队列**
- 当然还有一个全连接队列，就是**已经完成三次握手**，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象
- 这里在补充一点关于SYN-ACK 重传次数的问题： 服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。 注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s......

**ISN（初始序列号）是固定的吗：**
当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。
**三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)**，**以便让对方知道接下来接收数据的时候如何按序列号组装数据**。**如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的**

**三次握手过程中可以携带数据吗？**
**第一、二次握手不可以携带数据，第三次可以**

- 为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文
- 第一二次握手不可以放数据，**其中一个简单的原因就是会让服务器更加容易受到攻击了**。而对于第三次的话，此时**客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了**，**所以能携带数据也没啥毛病**

**SYN攻击是什么：**
**服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的**，所以**服务器容易受到SYN洪泛攻击**。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由**于源地址不存在，因此Server需要不断重发直至超时**，**这些伪造的SYN包将长时间占用未连接队列**，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。**SYN 攻击是一种典型的 DoS/DDoS 攻击**
检测 SYN 攻击非常的方便，当**你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击**。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击
解决方法：

   - 缩短超时（SYN Timeout）时间
   - 增加最大半连接数
   - 过滤网关防护
   - SYN cookies技术

### 23、为什么需要三次握手，两次不行吗
两次不行，两次服务端无法知道客户端的接收能力是否正常

- 第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
- 第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常
- 第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

因此，**需要三次握手才能确认双方的接收与发送能力是否正常**
### 24、网络的七层/五层模型主要的协议有哪些？
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1681800244811-c26f6a8a-a123-48a5-98e9-2217b3562b50.png#averageHue=%23f2ddb5&clientId=u33e0e403-54ac-4&from=paste&height=549&id=u411023d2&originHeight=823&originWidth=1436&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=269488&status=done&style=none&taskId=uff43fa47-5ce7-42a2-90fd-2908873c114&title=&width=957.3333333333334)

- 应用层协议
   - HTTP 超文本传输协议
   - HTTPS 超文本传输安全协议
   - DNS 域名解析服务
   - FTP 文件传输协议 	记忆：File TransPort
   - TFTP 简单文件传输协议
- 网络层协议
   - IP 网际协议，IP协议不但定义了数据传输时的基本单元和格式，还定义了数据报的递交方法和路由选择
   - ICMP Internet控制报文协议 
   - RIP 路由信息协议
   - IGMP Internet组管理协议
- 数据链路层协议
   - ARP 地址解析协议 通过IP地址获取物理地址
   - RARP 反向地址转换协议 通过物理地址获取IP地址
   - PPP 点对点协议


### 25、TCP四次挥手相关内容
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1681805063668-f4e6d208-d417-4826-8a53-884a613dbf07.png#averageHue=%23efe4cb&clientId=u33e0e403-54ac-4&from=paste&height=615&id=u8fd9faaf&originHeight=923&originWidth=1007&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=293469&status=done&style=none&taskId=uc4b5e653-5ba5-47b7-b622-92d0cadc550&title=&width=671.3333333333334)
建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由**TCP的半关闭（half-close）造成的**。所谓的半关闭，其实就是**TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力**。
**TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)**，客户端或服务器均可主动发起挥手动作
**四次挥手步骤：**
刚开始双方都处于 **ESTABLISHED** 状态，假如是客户端发送到数据已经发送完毕，四次挥手的过程如下

- 第一次挥手：客户端**发送一个 FIN 报文**，并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。此时客户端仍是可以接收数据的
- 第二次挥手：**服务端收到 FIN 连接释放报文之后，会发送 ACK 报文**，表明已经收到客户端的报文了，服务端进入**CLOSE_WAIT（关闭等待）状态**，**此时的TCP处于半关闭状态**，客户端到服务端的连接释放。**客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态**，等**待服务端发出的连接释放报文段**
- 第三次挥手：此时服务端向客户端把所有的数据发送完了，和客户端的第一次挥手一样，**发送 FIN 报文**，**表示客户端也可也关闭接收连接了，然后服务端进入LAST_ACK（最后确认）状态**，等待客户端的确认报文。
- 第四次挥手：客户端**收到 FIN 之后，一样发送一个 ACK 报文作为应答**，**客户端进入TIME_WAIT（时间等待）状态。服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。**此时TCP未释放掉，需要经过时间等待计时器设置的**时间2MSL后，客户端才进入CLOSED状态**

收到一个FIN只意味着在这一方向上不会再接收数据。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态

**挥手为什么需要四次？**

- 建立连接时，服务端收到客户端的SYN连接请求报文后，可以**直接发送SYN+ACK报文**。其中ACK报文是用来应答的，SYN报文是用来同步的
- 但是关闭连接时，当**服务端收到FIN报文时，很可能并不会立即关闭SOCKET**，所以只能先**回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"**。只有等到我**服务端所有的报文都发送完了**，我才能发送FIN报文，因此不能一起发送。故**需要四次挥手**

**2MSL等待状态**

- MSL，每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。
- 等待2MSL为了**保证客户端发送的最后一个ACK报文段能够到达服务器**。因为这个**ACK有可能丢失**，**从而导致处在LAST-ACK状态的服务器收不到对FIN的确认报文**。服务器会**超时重传**这个FIN报文，接着客户端再重新发送一次ACK确认报文，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，**服务器就无法正常的进入关闭连接状态**

预留两倍的msl就是为了防止第一次ack丢失，然后服务器等待回应超时后再发一次fin，客户端再发一次ack，多给了一次ack丢失的机会

### 26、对称密钥加密和非对称密钥加密

- 对称加密，**加密和解密使用同一密钥**
   - 优点：运算速度快
   - 缺点：无法安全地将密钥传输给通信方
- 非对称密钥加密，又称公开密钥加密（Public-Key Encryption），**加密和解密使用不同的密钥**

公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密

   - 优点：可以更安全地将公开密钥传输给通信发送方
   - 缺点：运算速度慢。

### 27、HTTPS是什么

- HTTPS 并不是新协议，而是让 **HTTP 先和 SSL（Secure Sockets Layer）通信**，**再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信**
- 通过使用 SSL，HTTPS 具有了**加密**（防窃听）、**认证**（防伪装）和**完整性保护**（防篡改）

**HTTP缺点：**

- 使用明文进行通信，内容可能会被窃听
- 不验证通信方的身份，通信方的身份有可能遭遇伪装
- 无法证明报文的完整性，报文有可能遭篡改

### 28、HTTPS采用的加密方式有哪些？是对称还是非对称？
HTTPS 采用**混合的加密机制**，使用**非对称密钥加密**用于**传输对称密钥来保证传输过程的安全性**，之后使用对**称密钥加密进行通信来保证通信过程的效率**。
**确保传输安全的过程（其实接收rsa原理）：**

- Client给出**协议版本号**、一个**客户端生成的随机数**（Client random），以及**客户端支持的加密方法**
- Server **确认双方使用的加密方法**，并给出**数字证书**（数字证书中包含了服务器的公钥）、以及一个**服务器生成的随机数**（Server random）
- Client确认数字证书有效，然后**生成一个新的随机数**（Premaster secret），并使用数字证书中**的公钥，加密这个随机数**，发给Server
- Server使用自己的**私钥，获取Client发来的随机数**（Premaster secret）
- Client和Server根据约定的加密方法，**使用前面的三个随机数，生成”对话密钥**”（session key），用来加密接下来的整个对话过程



### 29、拥塞控制
**要解决的问题：**
在⽹络出现拥堵时，如果继续发送⼤量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是⼀重传就会导致⽹络的负担更重，于是会导致更⼤的延迟以及更多的丢包，这个情况就会进⼊恶性循环被不断地放⼤。所以，TCP不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP会自我牺牲，降低发送到数据量
**拥塞控制，控制的目的接收避免「发送⽅」的数据填满整个网络。**
为了在发送方调节所要发送数据的量，定义了一个叫做**拥塞窗口**的概念。

- 拥塞窗口cwnd是发送方维护的一个状态变量，它会根据网络的拥塞程度动态变化的

**拥塞窗口cwnd变化的规则：**

   - 只要网络中没有出现拥塞，cwnd就会增大
   - 但网络中出现了阻塞，cwnd就会减少

**如何知道当前网络出现了拥塞？**
只要发送方没有在规定的时间内接收到ACK应答报文，也就是发生了超时重传，就会认为网络发生了拥塞。

### 29、TCP四大拥塞控制算法

拥塞控制主要是四个算法：1）**慢启动**，2）**拥塞避免**，3）**拥塞发生**，4）**快速恢复**。这四个算法不是一天都搞出来的，这个四算法的发展经历了很多时间，到今天都还在优化中

- **慢热启动算法 – Slow Start**

所谓慢启动，也就是TCP连接刚建立，一点一点地提速，试探一下网络的承受能力，以免直接扰乱了网络通道的秩序。
慢启动算法规则：**当发送方每收到一个ACK，拥塞窗口cwnd的大小就会加1。**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1681817892262-4d640137-9a85-42af-8e7a-860c18306c34.png#averageHue=%23f8f7f6&clientId=u33e0e403-54ac-4&from=paste&height=671&id=ud1fd79e1&originHeight=1007&originWidth=1217&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=266123&status=done&style=none&taskId=u48256ef8-196d-46a9-a79f-d948c07710f&title=&width=811.3333333333334)
可以看出慢启动算法，发送包的个数是指数性的增长。
有个慢启动门限ssthresh状态变量，一般来说ssthresh的大小是65535字节：**当cwnd<ssthresh时，就会启动慢启动算法**，**当cwnd>=ssthresh时，就会使用拥塞避免算法**

- **拥塞避免算法**

进入拥塞避免算法后，其规则是，每当收到一个ACK时，**cwnd增加1/cwnd**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1681818493625-48676cc4-16f7-4dbf-a601-5e7148132c79.png#averageHue=%23f9f6f3&clientId=u33e0e403-54ac-4&from=paste&height=673&id=u009fb189&originHeight=1010&originWidth=1022&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=145797&status=done&style=none&taskId=u6104af32-5fbc-44ef-b0f1-ded372c133e&title=&width=681.3333333333334)
拥塞避免算法就是将原本**慢启动算法的指数增长变成了线性增长**，**还是增长阶段，但是增长速度缓慢了一些，**随着增长，网络就会慢慢进入拥塞的状况，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传，**当触发了重传机制，也就进入了拥塞发生算法**

- **拥塞发生算法**

当网络出现拥塞，会发生数据包重传，重传机制有两种，分别是**超时重传和快速重传，**对于这两种方式的拥塞发生算法是不同的。
**发生超时重传：**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1681819583822-e9c3ea63-b941-47c9-8a52-3fc0045b98b6.png#averageHue=%23e6cea9&clientId=u33e0e403-54ac-4&from=paste&height=671&id=u70985890&originHeight=1006&originWidth=1017&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=122404&status=done&style=none&taskId=u3e9f6bd0-9218-47d4-b33f-d3556ac2cc3&title=&width=678)
这种方式太激进，反应也很强烈，会造成网络卡顿
**发生快速重传的拥塞发生算法**
当接收方发现丢了一个中间包的时候，**发送三次前一个包的ACK，于是发送端就会快速的重传丢失的包**，不必等待超时再重传。
TCP认为这种情况不严重，因为大部分没丢，只丢了一小部分，则ssthresh和cwnd变化如下：

   - **cwnd=cwnd/2，也就是设置为原来的一半**
   - **ssthresh=cwnd；**
   - **然后进入快速恢复算法**
- **快速恢复算法**

快速重传和快速恢复算法一般同时使用，快速恢复算法认为，你还能收到3个重复ACK说明网络也不那么糟糕，所以没必要像超时重传拥塞发生（RTO）那样激烈。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1681820126098-d026a46b-1336-4084-ab4c-880a81371303.png#averageHue=%23c5ebc9&clientId=u33e0e403-54ac-4&from=paste&height=358&id=u5413c0c3&originHeight=446&originWidth=1014&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=109371&status=done&style=none&taskId=u96b32a5e-927a-4cd2-87d1-200a257be6f&title=&width=815)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1681820147540-e34be6f2-51f9-4e24-bb22-7608c90ba4a2.png#averageHue=%23f7f4f0&clientId=u33e0e403-54ac-4&from=paste&height=541&id=uaaf3e104&originHeight=812&originWidth=1000&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=111729&status=done&style=none&taskId=ub31179fb-4cd5-477c-bf00-b62b45ae00e&title=&width=666.6666666666666)


### 30、流量控制原理
**概念**
发送方不能无脑的发数据给接收方，要考虑接收方处理能力。如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重传机制，从而导致网络流量的无端浪费
**为了解决这种现象发生，TCP提供一种机制可以让发送方根据接收方的实际接收能力控制发送的数据量，这就是所谓的流量控制。**

- TCP 利用滑动窗口实现流量控制。

TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。	发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报

- TCP是双工协议，双方可以同时通信，所以发送方接收方各自维护一个发送窗和接收窗。
   - 发送窗：用来限制发送方可以发送的数据大小，其中发送窗口的大小由接收端返回的TCP报文段中窗口字段来控制，接收方通过此字段告知发送方自己的缓冲（受系统、硬件等限制）大小
   - 接收窗：用来标记可以接收的数据大小
- TCP是流数据，发送出去的数据流可以被分为以下四部分：已发送且被确认部分 | 已发送未被确认部分 | 未发送但可发送部分 | 不可发送部分，其中发送窗 = 已发送未确认部分 + 未发但可发送部分。接收到的数据流可分为：已接收 | 未接收但准备接收 | 未接收不准备接收。接收窗 = 未接收但准备接收部分。
- 发送窗内数据只有当接收到接收端某段发送数据的ACK响应时才移动发送窗，左边缘紧贴刚被确认的数据。接收窗也只有接收到数据且最左侧连续时才移动接收窗口

### 31、如何区分流量控制和拥塞控制

- 流量控制属于**通信双方协商**；拥塞控制涉及**通信链路全局**。
- 流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。
- 实际最终发送窗口 = min{流控发送窗口，拥塞窗口}。

### 31、TCP协议如何保证可靠传输

- **确认和重传**：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传。
- **数据校验**：TCP报文头有校验和，用于校验报文是否损坏。
- **数据合理分片和排序**：tcp会按最大传输单元(MTU)合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层
- **流量控制**：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失
- **拥塞控制**：当网络拥塞时，通过拥塞控制，减少数据的发送，防止包丢失

### 32、封包和拆包
封包和拆包都是基于TCP的概念。因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，**确保发送和接收的数据不粘连**。

- 封包：封包就是在发送数据报的时候为每个TCP数据包加上一个包头，将**数据报分为包头和包体两个部分**。**包头是一个固定长度的结构体，里面包含该数据包的总长度**
- 拆包：接收方在接收到报文后提**取包头中的长度信息进行截取**



### 33、TCP和UDP的区别

- TCP面向连接;UDP是无连接的，即发送数据之前不需要建立连接
- TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，但不保证可靠交付
- TCP面向字节流，实际上是TCP把数据看成**一连串无结构的字节流**;UDP是面向报文的
   - TCP是面向字节流的，它把上面应用层交下来的数据看成无结构的字节流发送，可以想象成流水形式的，发送方TCP会将数据放入“蓄水池”（缓存区），等到可以发送的时候就发送，不能发送就等着。TCP会根据当前网络的拥塞状态来确定每个报文段的大小。
   - UDP是面向报文的，发送方的UDP对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层，无论应用层交给UDP多长的报文，它统统发送，一次发送一个。而对接收方，接到后直接去除首部，交给上面的应用层就完成任务了。因此，它需要应用层控制报文的大小
- 每一条TCP连接只能是端到端的;UDP支持一对一，一对多，多对一和多对多的交互通信
- TCP首部开销20字节;UDP的首部开销小，只有8个字节
- TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

### 34、RTO,RTT和超时重传

- 超时重传：发送端发送报文后若长时间未收到确认的报文则需要重发该报文
- RTO：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间。就是**重传间隔**
   - 通常每次重传RTO是前一次重传间隔的两倍，计量单位通常是RTT。例：1RTT，2RTT，4RTT
   - 重传次数到达上限之后停止重传
- RTT：数据从发送到接收到对方响应之间的时间间隔，即数据报在网络中一个往返用时。大小不稳定


# 项目
# 

## 
## 面试准备
### 1、自我介绍
面试官您好，非常感谢贵公司给我这次面试的机会。
我叫彭弈博，今年研究生二年级，本硕都在上海大学机电工程与自动化学院，分别就读于电气工程及其自动化和电子信息专业。研一在校期间重点位于导师的横向项目，主要研究方向是机器视觉。
研二我在继续做毕业课题方向的项目的同时，学习了C++软件开发相关的知识，自学了操作系统、计算机网络等课程。我主要做了两个项目，一个是实验室的横向项目，一次性医疗内窥镜图像处理系统，是基于C++和机器视觉开发了Linux嵌入式软件项目。我主要负责系统软件开发以及部分嵌入式开发。另一个是C++服务器开发相关的项目,TinyWebServer，这个项目实现了一个小型服务器，让我熟悉了网络编程和系统编程，对操作系统和计算机网络有了更深刻的理解。
这两个项目让我对C++开发技术有了更浓厚的兴趣，并决定在这个方向深耕学习。随着研二马上结束，我也有了大量的空闲时间，希望通过实习丰富自己的经历和技术栈。希望能进入贵公司，为公司创造价值的同时不断进步。我的自我介绍完毕，感谢面试官的倾听

# 
### 2、你认为自己有什么优点，在工作中会比别人好
主要有两个优点吧

- 学习能力强，研究生初试专业第一420分，我认识我在学习能力上有一点优势，学习新东西的速度会比别人快，进入公司学习新技术也会更快一点
- 沟通合作能力比较好，我在学校做了很多学生工作，包括志愿者阿，还有在学院的研究生会任学术部部长，负责学院学术会议的统筹规划，因此在团队合作方面比较有优势。



### 3、你认为自己有什么缺点？
您这个问题问的很好，我在找工作时也认真分析过自己的优缺点。
在以前的学习经历中，我发现自己有时候容易走神，导致我在集中注意力上花费更多时间。我意识到这会对学习或者工作的整体效率造成影响，一直在采取一些措施去改进这个问题。
比如积极创造有利于专注的学习环境，把会干扰到我的手机之类的专门放起来，也尝试过采用一种工作方法，番茄工作法，通过设置定时器，将学习或工作时间分割成短暂的工作块，每个工作块后有短暂的休息时间，这种方法也能帮助我集中精力并保持专注。后续我也会更努力的改进自己这样的缺点。

### 4、为什么想找这个领域的工作

- 我对软件开发比较感兴趣，用软件实现一项需求、一个功能可以让我很有成就感，我也主动学习了一些嵌入式软件开发相关的课程，比如操作系统，Linux相关的课程等。
- 在学校主要做的课题一次性医疗内窥镜图像处理系统也是嵌入式相关的项目，我主要负责软件部分的开发，这让我对该嵌入式开发有了更深入的了解
- 嵌入式系统应用广泛，从电子产品到医疗设备，工业自动化等，有较好的发展前景，因而我想找这个领域的工作
### 5、如何学习这个领域的，学习过程

- 首先是从网上找寻相关的课程和博客，网络上的资源很多，遇到什么问题都会先自己找寻
- 其次是询问指导老师或者高年级的师兄，他们在项目上的经验多于自己，遇到一些自己无法解决的就会像他们进行学习
# 

### 6、职业规划，对未来发展的规划

- 首先是通过实习，丰富自己的技术栈，提升自己的视野，实习我认为是学生迈出校园踏入社会的第一步，可以有机会向许多前辈学习，我会利用实习机会去更好的提升自己
- 我对嵌入式软件开发有着深厚的兴趣，实习结束之后，我也会利用好时间继续在这个方向深耕，秋招我的目标也还会是这个方向
- 我希望在未来可以在海康威视这样的优秀企业工作，可以给员工提供较大的平台，让我更好的成长，这对我的职业发展是有很大好处的，我希望在这样的企业不断地学习优秀文化和技术，未来能在工作领域有更大的成就。
### 7、对公司的了解

- 海康威视
   - 对海康威视的了解

海康威视是一家专注于技术创新的科技公司，公司的产品涉及智能物联、人工智能和大数据技术等领域。海康威视最著名的是其视频监控产品，涵盖了安防监控领域的各个方面。并且逐渐将人工智能和大数据分析等技术与视频监控相结合，可以给客户提供更好的解决方案，给社会安全和公共安全做出了积极的贡献。还有就是海康慧影，之前参观过一些内窥镜展览会，在上面也看到过海康威视，在内窥镜镜头这一方面海康威视也是国内顶尖的

   - 了解超新星吗

是面向2024毕业生开展的实习生项目，通过学习培训、导师带教、项目实战相结合的培养方式，助力同学们快速成长

   - 选择海康的原因
      - 海康威视作为智能物联和大数据服务行业的巨头，可以给我提供更好的学习平台，让我扩充自己的视野
      - 超新星实习生的培养方式，让我感受到海康威视对实习生培养的重视，我相信在海康威视实习可以让我学到有价值的东西
      - 实习福利，住宿补贴
### 8、对该岗位的理解和后续发展情况的理解，是否考虑过考公
软硬结合，我本身也能看懂一些电路图，后续我会提升自己软件方面的技术

### 9、面试过类似岗位的公司有几家，觉得共同点是什么
面试过华为还有一家小公司，我觉得共同的特点是都比较注重技术。但华为和海康威视都有着更高的全球影响力，且在各自的行业都处于领先地位。
### 10、在挑战杯中你扮演什么角色，主要负责哪些部分
在挑战杯中我是第二负责人，因为是以我的课题项目参赛的，首先该比赛作品软件是我负责开发的，其次我需要负责申报材料的撰写，，还有作为答辩选手之一参与比赛答辩，团队中大部分都是师弟师妹，还会给他们一些成果方向上的建议。

### 11、作为部长在管理方面遇到的问题，如何与其他同学进行沟通的
      干事都是研一，都在另一个校区，通勤时间要一个小时，这就导致平时一些会议的举办他们参加的积极性不够，再加上他们研一还有课，会经常面临人手不足的情况，这个时候如何调动他们的积极性

### 12、对比那一家公司，你觉得海康优点在哪里？
 为什么选择海康？

### 13、面临压力最大的事情
考研，我认为对我来说最近几年压力最大的就是考研，在大学学习不像高中，有老师督促你，考研只能靠自己，从学习到报名以及各种流程。再加上我正式开始的晚，到十月底就开始觉得自己学不完，每天从早上九点到晚上十一点不停歇的学习。这就是我压力最大的事情
### 14、如何处理压力，喜欢做什么来处理压力
我平时很喜欢听音乐，考研的时候每天做题之类的我都会听音乐，音乐不会让我分心，反而让我更专注更轻松，压力太大就停下来听一首喜欢的歌，减轻自己的压力。
### 15、成就感最高的事情
对每个人来说成就感是不一样的，对我来说成就感最高的事情就是我目前的研究生生活没有白费，很充实。我是以专业第一，初试420分的成绩考到本校上海大学的，专业第一可能对一些人来说就已经是成就感高的事情了，但对我而言，我觉得我报名的时候还是不够胆大，低估了自己，420分上一些不错的985都是很有希望的。然后研究生期间呢，我连拿两年一等学业奖学金，成功当选学院研究生学生会的学术部部长，自己的课题项目也是感兴趣的方向，并且拿到了挑战杯市赛特等奖，研究生期间也拿到了入党的名额，我认为我的研究生很充实，这就是我成就感最高的事情

### 16、学一个陌生东西的经历
比如服务器这个项目，对我来说是完全陌生的，没有接触过这方面的知识，先从一些网站博客上找寻学习的方法，从基础的操作系统和计算机网络学起，然后再看网课学习网络编程，系统编程，碰到抽象的难以理解的知识就去看书，看比较好的文章。
### 17、过去实现的最成功的计划
学习上的话：考研，我在少的时间里通过自己的计划，让自己效率达到最高，每门课程我都有自己的计划和时间，印象最深的是专业课，我在十天内完成了专业课网课的学习以及课后习题的练习。最后也取得了专业第一的好成绩
生活上的话：运动健身，研一的时候我每天抽时间坚持运动健身，因为本身我比较瘦，运动细胞可能不太好，坚持健身计划让自己健康和体型更好
### 18、你最讨厌的人或者事的类型
不负责任、不认真的人
### 19、说一个你做不是你分内事情的经历
比如疫情在外隔离，导师让帮他国外的朋友写题，都是一些高中知识的题，但还会说锻炼我们
### 20、你对海康的加班文化怎么看
我认为加班是提供给愿意奋斗的人的，有些人喜欢躺平，有些人喜欢奋斗，加班文化给了这些愿意奋斗的人一个选择，可以有更多的时间去提升自己，去提高收入。对于我来说，我很喜欢能在年轻的时候奋斗一把，趁着年轻拼一把，因此我认为加班文化比较适合我。
## 一次性医疗内窥镜图像处理系统

### 1、介绍
该项目是要设计一个一次性医疗内窥镜图像处理系统主机，采用JestonNano核心板并自行设计底板，将内窥镜图像传感器采集到的图片高质量的显示在界面上,并辅以多种交互功能,方便医生观察病灶。
我主要负责软件系统的开发以及部分嵌入式开发。

- 软件系统

使用C++编程和QT实现图形化界面，从传感器读取图片显示到界面上，并添加多种图像处理功能按键，还有录像、暂停
多线程：
只有一个线程的话，无法做到一边读取图像一边显示到界面上，并且主线程还负责界面操控，总不能说每次都等图像读取处理完界面才能操控，因而申请了一个线程负责处理图像，而主线程只需要显示图片，操控各项基础功能即可。
生产者、消费者模型：
处理图像线程负责生产，处理图像线程负责从图像传感器读取图片，而要将图像处理过后才能显示在主线程中，因而设计了一个图像缓冲队列，处理图像线程每处理完一张图片，要将该图片加入到缓冲队列中，加入之前要先对缓冲队列上锁，加入完成再解锁
而主线程负责从缓冲队列中取图片显示在界面上，当缓冲队列不为空时，则加锁，取出图片并解锁，然后显示到界面上

部分C++11新特性，范围for等

嵌入式部分的开发
1、UART串口通讯，本项目的图形化界面采用触摸屏操控，我们采用了迪文触摸屏，并通过UART串口和核心板进行通讯，从而控制程序
2、熟悉嵌入式图形界面开发：了解嵌入式图形界面开发的基本原理和技术，项目在Linux系统采用QT开发图形化界面
3、了解Shell编程，在项目中采用Shell编写一些脚本来简化开发工作
4、利用核心板的GPIO口控制内窥镜前端LED灯的亮度等/


### 2、这个项目中你遇到的最大的困难是什么？

- 硬件方面，因为自己负责了一部分的电路测试，pcb调试起来是要比软件麻烦的，比如触摸屏和主板之间的通信，主板通信是TTL通信，而触摸屏是232通信，于是我们采用了一个转换芯片，对TTL和232进行双向转换，但测试的时候先是无法进行通信，主板向外发送数据示波器无法检测到信号，测试发现是使能引脚虚焊，连接上之后触摸屏向主板发送是正常的，但是主板向外发送是乱码，研究了芯片手册发现芯片工作是正常的，但就是输出乱码，更换了另一型号的芯片才工作正常。
- 软件方面，读取图像的线程处理好图像后，主线程再将图像显示到界面当中，一开始图像就只是定义了一个变量，然后经常出现访问冲突的报错，后来发现是两个线程会同时访问同一块内存区域，当时只是用了一个全局变量，保证主线程已经显示好图像了，然后图像处理线程再去对图像进行赋新处理好的图像，后来学习了操作系统，就使用了生产者消费者模式，建了一个图像缓冲队列，处理线程作为生产者，处理好图像就放入队列中，然后主线程作为消费者，从队列中读取图像

### 3、生产者消费者这里，实现同步的细节。
最开始用全局变量去实现



### 4、软件的框架，主要包括哪些部分？

- 图像获取处理模块：一个单独的线程负责该模块，将图像读取，然后处理之后，由主线程将其显示在界面上
- 图像显示模块：主线程负责图像显示，将图像处理线程处理好的图像显示在界面上，同时还包含一些业务逻辑，比如录像、暂停等操作
- 功能操控模块：读取触摸屏发送的串口数据并解析，对数据进行解析，与点击的操作对应起来。


### 5、白平衡这些算法，介绍一下如何实现的?
白平衡原理是，如果原始场景中的某些像素点应该是白色的（即R=G=B=255），但是由于图像存在色偏，这些点的R、G、B三个分量的值不再保持相同，通过调整这三个颜色分量的值，使之达到平衡，由此获得对整幅图像的彩色平衡映射关系，通过该映射关系对整幅图像进行处理，即可达到彩色平衡的目的


### 6、内存管理遇到的bug，具体说说

- 比如一个指针定义的时候没有赋初值，为空指针，对其进行赋值之前可能有代码就已经使用该指针了，会报空指针异常的错误，所以一个指针要是定义的时候没有初始化，使用指针之前一定要判断指针是否为空。
- 比如一个指针指向的内存已经释放了，但是指针没有置为空，之后代码中又用到了这个指针，程序就会报错
- 没有正确释放动态分配的内存，导致内存泄漏问题，这可能会导致服务器长时间运行后出现内存耗尽或崩溃

### 7、软件上遇到的最印象深刻的bug是什么
 两个线程访问同一块资源,造成访问冲突。后面采用生产者消费者模型，创建了一个图像缓存队列，利用信号量和锁实现两个线程对该公共资源区域的互斥与同步访问。解决了访问冲突的问题。信号量用来记录队列中资源数量，锁用来保证同一时刻只有一个线程可以对队列进行操作
```cpp
#include <iostream>
#include <queue>
#include <pthread.h>
#include <semaphore.h>

const int BUFFER_SIZE = 10;
std::queue<int> buffer;
pthread_mutex_t mutex;
sem_t emptyCount, filledCount;

void* producer(void* arg) {
    for (int i = 1; i <= 20; ++i) {
        sem_wait(&emptyCount);
        pthread_mutex_lock(&mutex);

        buffer.push(i);
        std::cout << "Produced: " << i << std::endl;

        pthread_mutex_unlock(&mutex);
        sem_post(&filledCount);
    }

    pthread_exit(NULL);
}

void* consumer(void* arg) {
    for (int i = 1; i <= 20; ++i) {
        sem_wait(&filledCount);
        pthread_mutex_lock(&mutex);

        int item = buffer.front();
        buffer.pop();
        std::cout << "Consumed: " << item << std::endl;

        pthread_mutex_unlock(&mutex);
        sem_post(&emptyCount);
    }

    pthread_exit(NULL);
}

int main() {
    pthread_mutex_init(&mutex, NULL);
    sem_init(&emptyCount, 0, BUFFER_SIZE);
    sem_init(&filledCount, 0, 0);

    pthread_t producerThread, consumerThread;

    pthread_create(&producerThread, NULL, producer, NULL);
    pthread_create(&consumerThread, NULL, consumer, NULL);

    pthread_join(producerThread, NULL);
    pthread_join(consumerThread, NULL);

    pthread_mutex_destroy(&mutex);
    sem_destroy(&emptyCount);
    sem_destroy(&filledCount);

    return 0;
}

```
### 8、录像在保存视频之前，录制的图像是存在哪里的，内存中吗？

创建一个VideoWriter对象并打开一个视频文件时，OpenCV会将图像数据编码为视频帧，并将这些帧写入指定的文件。图像资源通常在内存中存储，直到被编码和写入文件
### 9、cpu内存多大，有遇到内存吃紧的情况吗
NVIDIA Jetson Nano采用的是ARM架构的处理器，最高主频为1.43GHz，内存方面为4g
没有碰到过内存吃紧的情况












































## TinyWebServer
### 一、介绍
这是一个基于Linux的C++轻量级Web服务器，使用线程池、socket、epoll和事件处理机制来实现并发模型，支持解析GET和POST请求，访问数据库实现用户注册和登录功能，同时具备日志系统记录服务器运行状态，并经Webbench压力测试实现上万的并发连接数据交换。
#### 1、整程
#### 2、日志部分

- 首先在main中运行webserver.cpp中的log_write函数
   - log_write函数中根据m_log_write变量决定了日志的写入方式，如果是1则是异步写入，否则是同步写入
- Log日志类采用单例模式，而在log_write函数中，通过调用Log日志类的get_instance来获取带日志类唯一对象的地址，并且调用该对象中的init函数对类中的一些成员变量进行初始化
   - 初始化的参数有日志文件名字，日志缓冲区大小，日志最大行数，还有日志阻塞队列，而日志阻塞队列的值决定了是异步写入还是同步写入，因为同步写入是直接写入文件，不用将要写的数据放入阻塞队列中。因而日志阻塞队列的大小不为0，则说明是异步写入，为0则同步写入
   - write_log函数，是写日志的函数，函数负责组装好要写的日志数据，还有如何同步写入日志。函数第一个参数表示输出何种类型的日志。还有一个可变参数的宏，可以代表多个参数
   - async_write_log函数，异步写日志的方法，从阻塞队列中取出日志，然后写入文件
- Log.cpp文件，主要详细描述了init函数和write_log函数
   - init函数
      - 首先根据阻塞队列参数判断是同步写日志还是异步，如果是异步，创建阻塞队列，并创建线程，回调函数设置为flush_log_thread，用来异步写日志
      - **初始化参数**：然后初始化类中的一些参数，如缓冲区大小，日志最大行数等
      - **确定日志文件名**：寻找filename参数中是否有'/'，没有的话说明日志文件没有自定义名字，直接将时间+文件名作为日志名。有的话则有自定义文件名，并记录文件路径，确定日志文件名
      - **打开文件**：记录日志初始化的这一天，并以追加的形式打开文件，得到文件指针m_fp
   - write_log
      - 确定日志输出类型：根据第一个参数确定日志输出类型
      - 判断日志时间和最大行数：如果当前day不是为创建日志的时间或当前行数等于了最大行数，则要创建新的文件。如果当前day不是创建日志的时间，则创建今天的日志，并更新创建日志时间。如果是因为超过了最大行，则新日志名字为之前日志名基础上加后缀。创建好后更新文件指针
      - 格式化输出：将写入的具体时间和内容格式化，放入缓冲区中，并存到log_str中。如果为异步写入并且阻塞队列不满，则将要写的日志内容放入阻塞队列。若为同步写入，则直接向文件写入log_str.

#### 3、数据库连接池部分

- 首先在main中运行webserver.cpp中的sql_pool函数，sql_pool通过获取数据库连接池对象，然后对数据库连接池进行初始化
- 数据库连接池类connection_pool也是采用了单例模式实现，主要包含一个初始化函数init，还有一个connectionRAII类，可以通过此类封装数据库连接池的获取和释放，避免手动释放
- 实现cpp文件
   - init函数
      - 初始化一些参数，包括主机地址、数据库端口号、用户名和密码、数据库名、日志开关，还有数据库最大连接数
      - 根据数据库最大连接数，创建该数量的连接并初始化，并将这些连接加入到数据库连接池队列中
      - 将信号量初始化为最大连接次数
   - GetConnection函数，主要用来获取连接，如果数据库连接池不为空，则更新信号量、更新空闲连接数和当前连接数，并取出队头的连接
   - ReleaseConnection函数，主要用来释放连接，用完的连接重新加入到连接池中。更新信号量、更新空闲连接数和当前连接数。
   - DestroyPool函数：通过迭代器遍历连接池链表，关闭对应数据库连接，清空链表并重置空闲连接和现有连接数量
   - connectionRAII，不直接调用获取和释放连接的接口，将其封装起来，通过RAII机制进行获取和释放。

#### 4、线程池部分

- 首先在main中运行webserver.cpp中的thread_pool函数，在此函数中创建一个threadpool对象，并对该对象进行初始化，初始化参数有m_actormodel：模型切换    m_connPool:数据库连接池指针，m_thread_num:线程数量
- 线程池的设计模式为半同步/半反应堆，其中反应堆具体为Proactor事件处理模式。具体的，主线程为异步线程，负责监听文件描述符，接收socket新连接，若当前监听的socket发生了读写事件，然后将任务插入到请求队列。工作线程从请求队列中取出任务，完成读写数据的处理。
- 线程池主要包含了以下几个关键函数
   - threadpool构造函数，函数中根据传入的m_thread_num，创建同等数量的线程，这些线程的回调函数（也就是执行函数）是worker函数，同时将这些工作现场分离，不需要在进行手动回收。因为pthread的限制，worker函数被定义为静态函数，因此函数内部无法访问非静态成员，但this指针以参数的形式传递到了worker函数中
   - append函数，参数为一个任务对象，函数中会判断当前请求队列大小与限制大小，如果未超过限制大小，则将请求加入到请求队列中，同时信号量++，唤醒等待线程
   - worker函数，因为线程的回调函数必须是静态函数，因而worker函数被定义为静态函数，但是类成员静态函数内部是无法访问非静态成员的，因而this指针作为参数传递到了worker函数中。函数中将this指针强转为线程池类，从而调用成员方法run函数，run函数也是每个线程都在调用的一个函数
   - run函数，函数负责从请求队列中取出请求并处理，run函数中是一个while循环，每个线程都工作在各自的循环中
      - 取出任务或等待：函数先对m_queuestat信号量操作，如果此时信号量为0，说明队列中无任务，则阻塞在这里等待唤醒。被唤醒后先加互斥锁，判断请求队列是否为空。如果队列为空，可能是因为资源先被其他线程夺走了，于是解锁并跳过此次循环。不为空则从请求队列中取出第一个任务，将任务从请求队列删除
      - 处理任务，先从数据库连接池中取出一个数据库连接，然后调用http也就是任务类中的process函数对任务进行处理
#### 5、登录注册部分
本项目中，使用数据库连接池实现服务器访问数据库的功能，使用POST请求完成注册和登录的校验工作。

- get请求判断是注册还是登录，如果是注册，则返回注册页面，登录则返回登录页面
- 注册或登录输入密码后发送的是post请求，从请求体中取出对应的用户名或密码。如果是注册，会先检测数据库中是否有重名的，没有重名的再进行增加数据。如果是登录，则先找到数据库中是否有对应的用户名，有的话再判断密码是否正确。然后返回对应的页面。

#### 6、定时器
定时器主要有三个要点，第一是定时器，第二是定时器升序链表，第三是管理epoll文件描述符的类

- 首先是定时器，每个客户连接对应一个客户定时器对象，这个对象是由client_data结构体定义的，其中包含客户端的地址，文件描述符，还有对应的定时器节点timer。所有客户的定时器对象存在于一个数组中，为users_timer。客户端文件描述符为connfd的定时器就是users_timer[connfd]
- 然后是定时器升序链表
   - 链表中每个节点是util_timer类定义的对象，包括了该节点对应客户链接的超时时间，以及该节点的前后定时器节点，还有对应客户端定时器对象的地址users_timer[connfd]。还有回调函数，当该节点超时时，调用cb_func删除该节点，断开对应客户连接
   - 升序链表为sort_timer_lst类定义的对象，类中封装了链表的头尾节点。还有操作链表的几个函数，
      - add_timer：向链表中添加定时器节点。
      - adjust_timer：调整定时器链表顺序，当由客户连接发生事件时，会更新超时时间，需要更新对应的定时器节点
      - del_timer：删除定时器节点
      - tick()：定时任务处理函数，每次收到SIGALRM信号，就调用该函数，判断超时连接然后处理掉
- 最后是管理epoll文件描述符和信号的类Utils，类中有几个函数负责处理信号
   - sig_handler：信号处理函数，捕捉到SIGALRM信号时，就调用该函数，向管道发送消息
   - addsig：设置信号捕捉函数，捕捉SIGALRM等信号，并设置sig_handler为回调函数
   - timer_handler：定时处理任务，每次主线程从管道接收到型号时，调用该函数，该函数调用升序链表的tick函数，并重新定时

流程：

- 在webserver.cpp中初始化定时器各种参数，比如发送信号周期，设置信号捕捉函数捕捉SIGALRM等信号，设置管道。通过timer函数设置每个客户连接的定时器对象，超时时间等，并加入到升序链表中
- 每次接收到新的客户连接，就为其初始化定时器对象，加入到升序链表。每次客户连接有事件发生，就更新其定时器。如果客户结束连接，就删除其定时器
- 每过一段规定的事件，alarm函数会发送SIGALRM信号，向管道中发送信号类型等。然后主线程在epoll_wait之后遍历就绪事件集合，管道有收到信号就调用dealwithsignal函数，处理系统，进行应当的操作
- 每个连接请求下都有个timer变量，其中记录了该请求连接或者上一次发生时间的时间，以及超时时间，也就是到某个时间就超时了
- 存在一个超时请求链表，其中每个文件描述符对应的超时时间都存在其中，如果超时了就会将该连接删掉，如果在超时前该文件描述符上有事件发生，则会更新超时时间，并将超时时间重新插入到超时请求链表中

## 
### 二、问题
#### 项目介绍
#### 1、为什么要做这样一个项目？
实验室的项目偏向于机器视觉，感觉自身对于后台开发的知识有点薄弱，故此想学习有关服务器后台开发的相关知识；

#### 2、介绍一下你的项目
这是一个基于Linux的C++轻量级Web服务器，使用线程池、socket、epoll和事件处理来实现并发模型，支持解析GET和POST请求，访问数据库实现用户注册和登录功能，同时具备同步/异步日志系统记录服务器运行状态，并经Webbench压力测试实现上万的并发连接数据交换。

#### 线程池相关
#### 3、手写线程池

#### 4、线程的同步机制有哪些？
信号量、条件变量、互斥量等
#### 5、线程池中的工作线程是一直等待吗？
是的，等待新任务的唤醒
#### 6、你的线程池工作线程处理完一个任务后的状态是什么？
如果请求队列为空，则该线程进入线程池中等待；若不为空，则该线程跟其他线程一起进行任务的竞争
#### 7、如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？
该项目是基于IO复用的并发模式。**但不是一个客户连接就对应一个线程**！当客户连接有事件需要处理的时，epoll会进行事件提醒，而后讲对应的任务加入请求队列，等待工作线程竞争执行。**如果速度还是慢，那就只能够增大线程池容量**，或者考虑集群分布式的做法
#### 8、如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢?
会，因为线程的数量是固定的，如果一个客户请求长时间占用着线程资源，势必会影响到服务器对外的整体响应速度。解决的策略可以是给每一个线程处理任务设定一个时间阈值，当某一个客户请求时间过长，则将其置于任务请求最后，或断开连接

#### 并发模型相关
#### 9、简单说一下服务器使用的并发模型？
**该项目选用的半同步半反应堆的并发模型**

- 以Proactor模式为例的工作流程即是：主线程充当异步线程，负责监听所有socket上的事件
- 若有新请求到来，主线程接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件
- 如果连接socket上有读写事件发生，主线程从socket上接收数据，并将数据封装成请求对象插入到请求队列中
- 所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权
#### 10、reactor、proactor、主从reactor模型的区别？

- **Reactor模式**：要求主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生（可读、可写），若有，则立即通知工作线程，将socket可读可写事件放入请求队列，**读写数据、接受新连接及处理客户请求均在工作线程中完成。(需要区别读和写事件)**
- **Proactor模式**：主线程和内核负责处理读写数据、接受新连接等**I/O操作**，**工作线程仅负责业务逻辑（给予相应的返回url）**，如处理客户请求。
- **主从Reactor模式**：核心思想是，主反应堆线程只负责分发Acceptor连接建立，已连接套接字上的I/O事件交给sub-reactor负责分发。其中 sub-reactor的数量，可以根据CPU的核数来灵活设置。**主反应堆线程一直在感知连接建立的事件**，如果有连接成功建立，主反应堆线程通过accept方法获取已连接套接字，**接下来会按照一定的算法选取一个从反应堆线程**，并把已连接套接字**加入到选择好的从反应堆线程中。**主反应堆线程唯一的工作，就是调用accept获取已连接套接字，以及将已连接套接字加入到从反应堆线程中
#### 11、你用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？
先说说其他的复用方式吧，比较常用的有三种：select/poll/epoll

- 对于select和poll来说，所有文件描述符都是在用户态被加入其文件描述符集合的，**每次调用都需要将整个集合拷贝到内核态，让内核态通过遍历文件描述符集合的方式来检查是否有网络事件发生，然后再拷贝回内核态**；epoll则将整个文件描述符集合维护在内核态，每次添加文件描述符的时候都需要**执行一个系统调用**。系统调用的开销是很大的，而且在有很多短期活跃连接的情况下，epoll可能会慢于select和poll由于这些大量的系统调用开销
- select使用线性表描述文件描述符集合，**文件描述符有上限**；poll使用**链表来描述**；epoll底层通过红黑树来描述，并且维护一个链表来记录就绪事件，将事件表中已经就绪的事件添加到该链表，在使用epoll_wait调用时，仅观察这个链表中有没有数据即可
- select和poll的最大开销来自内核判断是否有文件描述符就绪这一过程：每次执行select或poll调用时，**它们会采用遍历的方式**，遍历整个文件描述符集合去判断各个文件描述符是否有活动；epoll则不需要去以这种方式检查，当有活动产生时，**会自动触发epoll回调函数通知epoll文件描述符**，然后内核将这些就绪的文件描述符放到之前提到的**链表中等待epoll_wait调用后被处理**
- select和poll都只能工作在**相对低效的LT模式下**，而epoll同时支持LT和ET模式
- 综上，**当监测的fd数量较小**，且各个fd都很活跃的情况下，建议使用select和poll；**当监听的fd数量较多**，且单位时间仅部分fd活跃的情况下，使用epoll会明显提升性能

#### HTTP报文解析相关
#### 12、用了状态机啊，为什么要用状态机？
有限状态机，是一种抽象的理论模型，它能够把有限个变量描述的状态变化过程，以可构造可验证的方式呈现出来。比如，封闭的有向图。有限状态机可以通过if-else,switch-case和函数指针来实现，从软件工程的角度看，主要是为了封装逻辑。有限状态机是一种逻辑单元内部的一种高效编程方法，在服务器编程中，服务器可以根据不同状态或者消息类型进行相应的处理逻辑，使得程序逻辑清晰易懂
#### 13、状态机的转移图画一下
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1682258844213-089b5870-d3a1-4a6e-a6c9-093a3af5c9c0.png#averageHue=%23ecc9ae&clientId=u13edff5e-543a-4&from=paste&height=932&id=udc414b7b&originHeight=932&originWidth=2009&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1421264&status=done&style=none&taskId=u6c8728bf-b39a-4520-b4fd-dec770067db&title=&width=2009)
#### 14、https协议为什么安全？
HTTPS 并不是新协议，而是让 **HTTP 先和 SSL（Secure Sockets Layer）通信**，**再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信**

#### 15、https的ssl连接过程
**确保传输安全的过程（其实接收rsa原理）：**

- Client给出**协议版本号**、一个**客户端生成的随机数**（Client random），以及**客户端支持的加密方法**
- Server **确认双方使用的加密方法**，并给出**数字证书**（数字证书中包含了服务器的公钥）、以及一个**服务器生成的随机数**（Server random）
- Client确认数字证书有效，然后**生成一个新的随机数**（Premaster secret），并使用数字证书中**的公钥，加密这个随机数**，发给Server
- Server使用自己的**私钥，获取Client发来的随机数**（Premaster secret）
- Client和Server根据约定的加密方法，**使用前面的三个随机数，生成”对话密钥**”（session key），用来加密接下来的整个对话过程

#### 16、GET和POST的区别

- get是获取数据，post是修改数据
- get把请求的数据放在url上， 以?分割URL和传输数据，参数之间以&相连，所以get不太安全。而post把数据放在HTTP的包体内（requrest body）
-  get提交的数据最大是2k（ 限制实际上取决于浏览器）， post理论上没有限制。
-  GET产生**一个TCP数据包**，浏览器会把**http header和data一并发送出去，服务器响应200(返回数据)**; POST产生两个TCP数据包，**浏览器先发送header，服务器响应100 continue**，**浏览器再发送data，服务器响应200 ok(返回数据)**。
-  GET请求会被浏览器主动缓存，而POST不会，除非手动设置
-  本质区别：GET是幂等的，而POST不是幂等的

**这里的幂等性：**幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果
正因为它们有这样的区别，所以**不应该且不能用get请求做数据的增删改这些有副作用的操作**。因为get请求是幂等的，在网络不好的隧道中会尝试重试。**如果用get请求增数据，会有重复操作的风险，而这种重复操作可能会导致副作用**（浏览器和操作系统并不知道你会用get请求去做增操作）
#### 数据库登陆注册相关
#### 17、登录说一下？
具体的涉及到**载入数据库表，提取用户名和密码，注册登录流程与页面跳转**。

- 载入数据库表，结合代码将数据库中的数据载入到服务器中；
- 提取用户名和密码，结合代码对报文进行解析，提取用户名和密码；
- 注册登录流程，结合代码对描述服务器进行注册和登录校验的流程；
- 页面跳转，结合代码对页面跳转机制进行详解

#### 18、你这个保存状态了吗？如果要保存，你会怎么做？（cookie和session）
可以利用session或者cookie的方式进行状态的保存。
cookie其实就是服务器给客户分配了一串“身份标识”，比如一个字符串。每次客户发送数据时，都在HTTP报文附带上这个字符串，服务器就知道你是谁了；
session是保存在服务器端的状态，每当一个客户发送HTTP报文过来的时候，服务器会在自己记录的用户数据中去找，类似于核对名单

#### 19、登录中的用户名和密码你是load到本地，然后使用map匹配的，如果有10亿数据，即使load到本地后hash，也是很耗时的，你要怎么优化？
这个问题的关键在于大数据量情况下的用户登录验证怎么进行？将所有的用户信息加载到内存中耗时耗利，对于大数据最便利的方法就是**进行hash，利用hash建立多级索引的方式来加快用户验证**。具体操作如下：
首先，将10亿的用户信息，利用大致缩小1000倍的hash算法进行hash，这时就获得了100万的hash数据，每一个hash数据代表着一个**用户信息块（一级）**；
而后，再分别对这100万的hash数据再进行hash，例如最终剩下1000个**hash数据（二级）**。
在这种方式下，服务器只需要保存1000个二级hash数据，当用户请求登录的时候，先对用户信息进行一次hash，找到对应信息块（二级），在读取其对应的一级信息块，最终找到对应的用户数据，

#### 20、用的mysql啊，redis了解吗？用过吗？


#### 定时器相关

#### 21、为什么要用定时器？
处理定时任务，或者非活跃连接，节省系统资源
#### 22、说一下定时器的工作原理
服务器就为各事件分配一个定时器。该项目使用SIGALRM信号来实现定时器，首先每一个定时事件都处于一个升序链表上，**通过alarm()函数周期性触发SIGALRM信号**，而后信号回调函数利用管道通知主循环，主循环接收到信号之后对升序链表上的定时器进行处理：若一定时间内无数据交换则关闭连接
#### 23、双向链表啊，删除和添加的时间复杂度说一下？还可以优化吗？
添加一般情况下都是O(N)，删除只需要O(1)。从双向链表的方式优化不太现实，可以考虑使用最小堆、或者跳表的数据结构
#### 24、最小堆优化？说一下时间复杂度和工作原理
最小堆以每个定时器的过期时间进行排序，最小的定时器位于堆顶，当SIGALRM信号触发tick（）函数时执行过期定时器清除，如果堆顶的定时器时间过期，则删除，并重新建堆，再判定是否过期，如此循环直到未过期为止
插入，O(logn)；
删除，O(logN)；

#### 日志相关
#### 25、说下你的日志系统的运行机制？
初始化服务器时，利用单例模式初始化日志系统，根据配置文件确认是同步还是异步写入的方式

#### 26、为什么要异步？和同步的区别是什么？
同步方式写入日志时会产生比较多的系统调用，若是某条日志信息过大，会阻塞日志系统，造成系统瓶颈。异步方式采用生产者-消费者模型，具有较高的并发能力
#### 27、现在你要监控一台服务器的状态，输出监控日志，请问如何将该日志分发到不同的机器上？（消息队列）
为了便于故障排查，或服务器状态分析，看是否需要维护；可以使用消息队列进行消息的分发，例如mqtt、rabitmq等等

#### 压测相关
#### 28、服务器并发量测试过吗？怎么测试的？
测试过，利用webbench，至少满足万余的并发量
#### 29、webbench是什么？介绍一下原理
是一款轻量级的网址压力测试工具，可以实现高达3万的并发测试。其原理：Webbench实现的核心原理是：父进程fork若干个子进程，每个子进程在用户要求时间或默认的时间内对目标web循环发出实际访问请求，父子进程通过管道进行通信，子进程通过管道写端向父进程传递在若干次请求访问完毕后记录到的总信息，父进程通过管道读端读取子进程发来的相关信息，子进程在时间到后结束，父进程在所有子进程退出后统计并给用户显示最后的测试结果，然后退出
#### 30、测试的时候有没有遇到问题？


#### 综合能力

#### 31、你的项目解决了哪些其他同类项目没有解决的问题？


#### 32、说一下前端发送请求后，服务器处理的过程，中间涉及哪些协议？


#### 33、你的项目巧妙在哪里，觉得比别人的服务器哪里很巧妙
epoll，多路复用

#### 34、这个并发量一万，为什么是一万，如何测出来的
webbench设置为10000，webbench压测上线为三万，当超过一万的时候程序就崩溃了
### 


# 手撕代码
# 
## 算法

#### 1、十大排序

- 冒泡排序，一个一个向后冒泡

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1683895426503-a36110aa-0d71-4f83-b3d9-fac4cf9ce23c.png#averageHue=%23eae0d0&clientId=u53aeeaf3-56eb-4&from=paste&height=701&id=u26e7e525&originHeight=701&originWidth=1030&originalType=binary&ratio=1&rotation=0&showTitle=false&size=439753&status=done&style=none&taskId=uf425b74c-2230-4391-ae00-6ea1400676f&title=&width=1030)
```cpp
void BubbleSort(vector<int> &num,int n){
    if(n<=1) return;
    bool is_swap;//判断该轮是否交换过，没有交换过说明顺序已经对了
    for(int i = 1;i<n;i++){//i表示是第几轮冒泡，结束一轮则后面有一个元素确认位置
        is_swap = false;
        for(int j = 1;j<n-i+1;j++){
            if(num[j]<num[j-1]){//如果不递增，交换
                swap(num[j],num[j-1]);
                is_swap = true;//表示有数据交换
            }
        }
        if(!is_swap)//如果没交换过，说明顺序没问题
        {
            break;
        }
    }


}
```

- 插入排序

算法描述：分未已排序和未排序，初始已排序区间只有一个元素，就是数组第一个元素。遍历未排序的每一个元素在已排序区间中找到合适的位置插入并保证数据一直有序
插入排序类似于冒泡，区别在于数组左侧的部分是有序的部分，起初该有序部分只有第一个元素，然后每次新加元素都是通过向左冒泡的形式插入到该有序部分中，随着有序部分越来越大，完成排序
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1683895396826-1852077c-da0e-45c0-ad78-91d47f4f9364.png#averageHue=%23f0dbc3&clientId=u53aeeaf3-56eb-4&from=paste&height=761&id=u032637d2&originHeight=761&originWidth=634&originalType=binary&ratio=1&rotation=0&showTitle=false&size=298937&status=done&style=none&taskId=uae2dde28-95c4-4c39-85f5-ded3915dd12&title=&width=634)
```cpp
void InsertSort(vector<int> &num,int n){
	if(n<=1) return;
	for(int i = 0;i<n;i++){//左侧有序部分的右边一位
		for(int j = i;j>0&&num[j]<num[j-1];j--){//i元素以向左冒泡的形式插入到左侧有序部分中
			swap(num[j],num[j-1]);
		}
	}
}
```

- 选择排序

算法描述：分为已排序和未排序区间。每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾
从未排序区找到最小的元素，放在已排序区的末尾
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1683896468582-6c9d25c0-eaf9-4cf2-abcd-679bd1ef20d8.png#averageHue=%23eedeca&clientId=u53aeeaf3-56eb-4&from=paste&height=933&id=u3a436a28&originHeight=933&originWidth=706&originalType=binary&ratio=1&rotation=0&showTitle=false&size=441842&status=done&style=none&taskId=ued55efec-123a-4227-b064-3ea614ee9d2&title=&width=706)
```cpp
void SelectSort(vector<int> &num,int n){
	if(n<=1) return;
	for(int i = 0;i<n;i++){
		int min = i;//找到未排序部分中最小的下标
		for(int j = i+1;j<n;j++){
			if(num[j]<num[min]){
				min = j;
			}
		}
		swap(num[i],num[min]);//将该最小元素交换到排序部分的末尾
	}
	
}
```

- 快速排序

算法描述：先找到一个枢纽；在原来的元素里根据这个枢纽划分，比这个枢纽小的元素排前面，比这个枢纽大的元素排后面，两部分数据依次递归排序下去直到最终有序
基准点都选排序范围内第一个元素，然后设立首尾哨兵，尾哨兵向前找第一个小于基准点的元素，首哨兵向后找第一个大于基准点的元素，找到了就互换位置，当首尾哨兵相遇时，基准点与当前哨兵位置交换位置，这样基准点左小于基准点，右边都大于其。然后递归快排左右区间
```cpp
void QuickSort(vector<int> &num,int begin,int end){
	if(begin>=end) return;
	int base = num[begin];//基准点
	int i = begin,j=end;
	while(i!=j){
		while(num[j]>=base&&j>i){
			j--;//从后往前找寻第一个小于基准点的元素
		}
		while(num[i]<=base&&j>i){
			i++;//从前往后找寻第一个大于基准点的元素
		}
		//都找到了,如果当前j>i，就交换
		if(j>i){
			swap(num[i],num[j]);
		}
		
	}
	swap(num[i],num[begin]);//将基准点换到该换的位置，此时基准点左侧都小于基准元素，右侧都大于
	
	QuickSort(num,begin,i-1);//递归左侧
	QuickSort(num,i+1,end);//递归右侧

}
```
#### 1、合并两个有序链表
```cpp
myList* merge(myList* l1, myList* l2) {

    if (l1 == nullptr) return l2;
    if (l2 == nullptr) return l1;
    myList head(0);
    myList* node = &head;
    while (l1 != nullptr && l2 != nullptr) {
        if (l1->val < l2->val) {
            node->next = l1;
            l1 = l1->next;

        }
        else {
            node->next = l2;
            l2 = l2->next;
        }
        node = node->next;
    }

    if (l1 == nullptr)
        node->next = l2;
    if (l2 == nullptr)
        node->next = l1;

    return head.next;

};
```
#### 2、翻转链表
```cpp
ListNode* ReverseList(ListNode* pHead) {
        if(pHead ==NULL) return NULL;//
        ListNode * cur = pHead->next;//先让cur指向下一个
        ListNode * prev = pHead;
        prev->next = NULL;
        while(cur)
        {
            ListNode * temp = cur;
            cur = cur->next;
            temp->next = prev;
            prev = temp;
        }
        newpHead = prev;
        return prev;


    }
```
#### 3、二叉树中和为某一值的路径
```cpp
bool traversal(TreeNode* root, int sum)
    {
        //确定终止条件
        if(!root->left&&!root->right&&sum==0) return true;//遇到叶子节点，并且计数为0
        if(!root->left&&!root->right) return false;//遇到叶子节点，且没有找到合适的边，直接返回


        //确定单层递归逻辑
        if(root->left)
        {
            if((traversal(root->left, sum-root->left->val))) return true;//向左递归，直接将减去rootval的sum传进去，也是回溯
        }
        if(root->right)
        {
            if(traversal(root->right, sum-root->right->val)) return true;
        }
        return false;//以上情况没找到，返回false
    }
    bool hasPathSum(TreeNode* root, int sum) {
        // write code here
        if(root == NULL) return false;
        return traversal(root,sum - root->val);
    }
```



## 代码

#### 1、单例模式实现

- 懒汉模式

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1683524247419-d6825a74-1ef1-4c69-b930-7c4fbfb65ea2.png#averageHue=%23292c30&clientId=u75ab920f-dbfc-4&from=paste&height=757&id=uc266938e&originHeight=1135&originWidth=999&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=118491&status=done&style=none&taskId=u2058e0cc-8c4d-4616-9295-8ddf2d7795c&title=&width=666)
为什么要用双检锁，只检测一次不行吗
如果只检测一次，在每次调用获取实例的方法时，都需要加锁，这将严重影响程序性能。双层检测可以有效避免这种情况，仅在第一次创建单例的时候加锁，其他时候都不再符合NULL == p的情况，直接返回已创建好的实例。

- 饿汉模式

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1683524348073-44be31dc-1b92-4018-9c40-d77bc09b0472.png#averageHue=%232a2d31&clientId=u75ab920f-dbfc-4&from=paste&height=330&id=u33f59026&originHeight=495&originWidth=547&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=39147&status=done&style=none&taskId=uc33279a5-30d1-4f4f-8997-5a18a76f483&title=&width=364.6666666666667)
饿汉模式不需要用锁，就可以实现线程安全。原因在于，在程序运行时就定义了对象，并对其初始化。之后，不管哪个线程调用成员函数getinstance()，都只不过是返回一个对象的指针而已。所以是线程安全的，不需要在获取实例的成员函数中加锁


#### 线程池
使用线程池技术的最大好处**是服务器可以避免因重复的建立和销毁线程带来的开销**，从而提高服务器对客户端的响应速度
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1683525068985-f5c45072-988f-416b-bfc5-53e5a822a512.png#averageHue=%232a2d30&clientId=u78042cbd-f6b2-4&from=paste&height=881&id=u4b3b2dee&originHeight=1321&originWidth=1015&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=172831&status=done&style=none&taskId=ub35a2630-a27a-4cb2-8d6d-589c90871f3&title=&width=676.6666666666666)

#### 生产者消费者
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26193741/1683943461646-6850af9a-d70d-42e3-b18c-c15e775b01f3.png#averageHue=%23332d55&clientId=u26532b60-ba17-4&from=paste&height=779&id=u122cb072&originHeight=1168&originWidth=1209&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=197262&status=done&style=none&taskId=u5d6af214-a136-4df8-bc53-e2ae2d8a385&title=&width=806)

# 工具









